<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七翼式</title>
  
  <subtitle>不对称</subtitle>
  <link href="http://localhost:5000/atom.xml" rel="self"/>
  
  <link href="http://localhost:5000/"/>
  <updated>2022-12-12T05:50:08.000Z</updated>
  <id>http://localhost:5000/</id>
  
  <author>
    <name>el_psy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flask记录-1</title>
    <link href="http://localhost:5000/2022/12/12/flask-self-1/"/>
    <id>http://localhost:5000/2022/12/12/flask-self-1/</id>
    <published>2022-12-12T04:40:41.000Z</published>
    <updated>2022-12-12T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源点"><a class="header-anchor" href="#源点">#</a>源点</h1><p>提高前端项目的体量，需要一个后端支撑。所以选了flask？<br>其实是根据项目面对人群进行的选择。<br>标注面对ml人群，他们很有可能直接一发anaconda，然后里面就默认安装flask。<br>对于那些需要做保密项目，安装开发环境艰难，开发环境简陋的比较友好？<br>毕竟在linux平台安装python的最简单方案就是anaconda。<br>在此记录一下flask项目中的一些bug。<br>毕竟bug数量已经是函数数量的好几倍了。</p><h1 id="启动"><a class="header-anchor" href="#启动">#</a>启动</h1><p>在flask文档中flask的启动是，首先设定一个flask相关的临时环境变量，然后通过<code>flask run</code>命令启动。<br>如果文件名是<code>app.py</code>等几种，也可以直接<code>flask run</code>。</p><p>我就直接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app = create_app()</span><br><span class="line">app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>其中<code>debug=True</code>开启了debug模式，如果修改文件，则自动重启flask服务。<br>这种方法适用于开发模式。<br>当然，我也没想着能够部署。</p><h1 id="cors"><a class="header-anchor" href="#cors">#</a>cors</h1><p>cors非常轻松。<br>直接安装<code>flask_cors</code>包。<br>然后在<code>config.py</code>中设置对应配置，然后导入即可。<br>然后就可以轻松在前端进行<code>ajax</code>通信了。</p><h1 id="json-web-token"><a class="header-anchor" href="#json-web-token">#</a>json web token</h1><p>可以看看<a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a><br>这里使用了<code>pyjwt</code>。<br>jwt分为三段。</p><blockquote><p>第一段是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 加密算法</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span> # 代表token类型是json web token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行base64转换。这是明文。</p></blockquote><blockquote><p>第二段是一些json记录。<br>其中一些键是保留字段。<br>在pyjwt中实现了一下<br><code>exp</code> (Expiration Time) Claim 到期时间<br><code>nbf</code> (Not Before Time) Claim 起始时间，在这之前的请求不予处理<br><code>iss</code> (Issuer) Claim 发行人<br><code>aud</code> (Audience) Claim 受众，我也不清楚这是什么<br><code>iat</code> (Issued At) Claim 发行时间<br>总之，我用了<code>iat</code>和<code>exp</code>，限制了token的生效时间。<br>然后自定义了一个<code>actor</code>字段描述用户角色。<br>最后把这段进行base64转换。这是明文。</p></blockquote><blockquote><p>第三段是密文<br>就是根据生成的密码，对第一段和第二段进行加密，防止用户修改第一段和第二段（第一段和第二段是明文）。<br>如果用户修改第一段和第二段，就可以通过密文和明文比对发现。<br>加密算法在第一段中声明了<br>或许还会用到hmac。hmac和hashlib都是Python的默认库。</p></blockquote><p>jwt加密密码是每次启动flask时清空，调用时如果为空使用<code>secret</code>包生成一份。</p><h1 id="auth"><a class="header-anchor" href="#auth">#</a>auth</h1><p>auth用户认证。包括用户身份认证，注册登录注销等。</p><p>首先使用了<code>flask_auth</code>包。<br>使用了里面的<code>HTTPTokenAuth</code><br>里面的认证机制有两个。</p><ol><li>authenticate<br>本来是用户名和密码进行验证。<br><code>HTTPTokenAuth</code>对应的则是token能否被验证。这里通过pyjwt进行。<br>对应的函数需要使用<code>@auth.verify_token</code>装饰一下</li><li>authorize<br>是用来验证用户的角色的。访问某些url需要验证一下用户角色。<br>而这个项目的用户角色存放在token中，在解析token时就返回了。<br>总之建议阅读这个<code>authorize</code>的源码。<br>说实话，源码比文档好读。。</li></ol><p>这里注册是密码直接明文放到数据库中了。至于如何加密，在flask文档中有。<br>登录就直接向前端发一个token。至于这个token后端也没有记录。<br>注销功能后端就直接没写。直接让前端删除token吧。反正前端估计也是我写。</p><h1 id="db"><a class="header-anchor" href="#db">#</a>db</h1><p>数据库使用的是python自带的sqlite3。<br>首先在flask文档里把db的句柄（就是sqlite3.connect返回的那个）存到了<code>g</code>对象中。<br>这是有原因的。<br>sqlite3的文件crud权限有同时只能有一个线程的限制。<br>所以文档里最后还有个<code>app.teardown_appcontext</code><br>但是我这里的<code>init_db</code>就直接运行<code>db.py</code>就可以了。。</p><h1 id="db-execute"><a class="header-anchor" href="#db-execute">#</a>db.execute</h1><p>在数据库操作中的bug。。<br>首先，这个<code>db.execute</code>可以进行字符串转换，防止注入（好像是这样的）。<br>然后输入数据时需要<code>()</code>，如果只有一个变量，勿忘在变量后加一个逗号。<br>同时进行多组时可以使用<code>executemany</code>。</p><h1 id="获得参数之后"><a class="header-anchor" href="#获得参数之后">#</a>获得参数之后</h1><p>第一步就是对参数的结构进行认证。<br>或者是确认参数类型？<br>为此直接在<code>utils.py</code>来了一发<code>req_need_key</code>函数。</p><h1 id="其他"><a class="header-anchor" href="#其他">#</a>其他</h1><p>当然还有问题。<br>比如在编写到中途时修改数据库结构。<br>反正直接一发<code>init_db</code>就可以。<br>还有<code>task</code>任务需要时间线限制。还没编写。<br>总之，问题多多。大不了交给前端。<br>反正前端也是在下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源点&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#源点&quot;&gt;#&lt;/a&gt;源点&lt;/h1&gt;
&lt;p&gt;提高前端项目的体量，需要一个后端支撑。所以选了flask？&lt;br&gt;
其实是根据项目面对人群进行的选择。&lt;br&gt;
标注面对ml人群，他们很有可能直接一发a</summary>
      
    
    
    
    <category term="后端" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/flask/"/>
    
    
    <category term="后端" scheme="http://localhost:5000/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-身份认证</title>
    <link href="http://localhost:5000/2022/12/03/auth/"/>
    <id>http://localhost:5000/2022/12/03/auth/</id>
    <published>2022-12-03T14:39:49.000Z</published>
    <updated>2022-12-03T15:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1><p>token，又是前端八股常考且必考。但总是云里雾里。<br>这篇文章里也差不多。<br>没事可以多看看</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 身份验证</a></li><li><a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a></li><li><a href="https://oauth.net/2/">OAuth 2.0</a></li></ul><h1 id="总领"><a class="header-anchor" href="#总领">#</a>总领</h1><p>到底怎么认证一个用户？<br>简答来说，就是在HTTP头部放一段密文，用于验证。<br>至于怎么放，放什么，五花八门。</p><h1 id="在mdn中"><a class="header-anchor" href="#在mdn中">#</a>在MDN中</h1><p>依据文章<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 身份验证</a><br>认证的流程基本就是，客户端请求，服务端通过<code>WWW-Authenticate</code>首部通知如何认证；然后经过认证后，客户端使用<code>Authorization</code>发送认证字段。</p><p>至于认证的方案：</p><ol><li>Basic (查看 RFC 7617，base64 编码凭证。),</li><li>Bearer (查看 RFC 6750，bearer 令牌通过 OAuth 2.0 保护资源),</li><li>Digest (查看 RFC 7616，只有 md5 散列 在 Firefox 中支持，查看 bug 472823 用于 SHA 加密支持),</li><li>HOBA (查看 RFC 7486（草案），HTTP Origin-Bound 认证，基于数字签名),</li><li>Mutual (查看 draft-ietf-httpauth-mutual),</li><li>AWS4-HMAC-SHA256 (查看 AWS docs).</li></ol><p>。。基本就是Basic和Bearer。剩下的我也不知道。。</p><p>Basic最简单了，用&quot;:&quot;将用户名和密码拼接，然后使用base64编码，就完事了。参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization">Authorization</a></p><p>Bearer的可以参见<a href="https://oauth.net/2/">OAuth 2.0</a>。反正我是没怎么看懂。</p><h1 id="cookie"><a class="header-anchor" href="#cookie">#</a>cookie</h1><p>首先cookie是什么样的？<br>在浏览器中的开发者工具中开启网络选项页可以看到，cookie在请求头中是一个字符串，可以格式化成一堆键值对。<br>总之是一个存放数据的地方。<br>在Storage api之前是主要存放数据的地方。</p><p>而在flask中的session变量存放的键值对也会放到cookie中</p><p>当然也可以存放密文用于身份验证。</p><h1 id="token"><a class="header-anchor" href="#token">#</a>token</h1><p>世界上或许有很多种token？或许吧。<br>但我只知道jsonwebtoken。<br>参见<a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a></p><p>jwt分为三部分，头部header，负载payload，签名Signature。<br>header包含两部分，token的类型，加密算法<br>payload包含各种信息。<br>Signature，需要计算。</p><p>首先，头部需要将json转换为字符串，然后经过base64。<br>然后负载也一样。<br>最后签名需要使用加密算法，将头部负载和密码一起放入。</p><p>在python中<br>base64可以用<code>base64</code>库，加密算法可以用<code>hashlib</code>库，hmac算法可以用<code>hmac</code>库。这些库都是默认就有的。<br>在js中<br>base64可以用<code>atob</code>和<code>btoa</code>函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;token，又是前端八股常考且必考。但总是云里雾里。&lt;br&gt;
这篇文章里也差不多。&lt;br&gt;
没事可以多看看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="auth" scheme="http://localhost:5000/tags/auth/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享</title>
    <link href="http://localhost:5000/2022/12/01/cors/"/>
    <id>http://localhost:5000/2022/12/01/cors/</id>
    <published>2022-12-01T05:01:27.000Z</published>
    <updated>2022-12-01T06:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1><p>首先，这篇是从<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS?qs=cors">跨源资源共享（CORS）</a>中弄出来的。<br>说起来，MDN还真是强大呢。<br>跨域资源共享，或称为CORS，是一种浏览器安全机制，需要后端的配合。现在前后端分离的趋势下，加给一种前端的源和后端的源的限制，以达到安全的目的。具体上是，在后端中设置一些访问的限制，主要是访问的源的限制，也有其他的限制；浏览器端中如果发现请求不符合后端服务器的限制，则返回请求失败。</p><h1 id="同源的定义"><a class="header-anchor" href="#同源的定义">#</a>同源的定义</h1><p>如果两个 URL 的 protocol、port (en-US) (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。</p><p>出自<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略</a></p><h1 id="什么情况下需要cors"><a class="header-anchor" href="#什么情况下需要cors">#</a>什么情况下需要CORS</h1><ul><li>前文提到的由 XMLHttpRequest 或 Fetch API 发起的跨源 HTTP 请求。</li><li>Web 字体（CSS 中通过 @font-face 使用跨源字体资源），因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图。</li><li>使用 drawImage() 将图片或视频画面绘制到 canvas。</li><li>来自图像的 CSS 图形 (en-US)。</li></ul><p>出自<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS?qs=cors">跨源资源共享（CORS）</a></p><h1 id="流程"><a class="header-anchor" href="#流程">#</a>流程</h1><ol><li>浏览器通过XHR或者Fetch等方式发起跨域资源请求。</li><li>判断是否为简单请求</li></ol><p>3.1. 如果是简单请求</p><blockquote><p>直接向后端发起请求，通过返回的响应头判断请求是否符合CORS的安全策略</p></blockquote><p>3.2. 如果不是简单请求</p><blockquote><p>先发起预检请求，判断是否符合CORS的安全策略<br>如果符合安全策略，再发送实际的请求</p></blockquote><h1 id="什么是简单请求"><a class="header-anchor" href="#什么是简单请求">#</a>什么是简单请求</h1><p>这实在是一个复杂的问题，估计在面试中把答案说出来，面试官也很少能弄清。<br>前3条还好，后两条比较难遇到。</p><ol><li>使用下列方法之一</li></ol><blockquote><p>GET, HEAD, POST</p></blockquote><ol start="2"><li>除了被用户代理自动设置的首部字段，允许人为设置的字段为Fetch规范定义的对 CORS 安全的首部字段集合：</li></ol><blockquote><p>Accept<br>Accept-Language<br>Content-Language<br>Content-Type（需要注意额外的限制）<br>Range（只允许简单的范围首部值 如 bytes=256- 或 bytes=127-255）</p></blockquote><ol start="3"><li>Content-Type 首部所指定的媒体类型的值仅限于下列三者之一：</li></ol><blockquote><p>text/plain<br>multipart/form-data<br>application/x-www-form-urlencoded</p></blockquote><ol start="4"><li>如果请求是使用 XMLHttpRequest 对象发出的，在返回的 XMLHttpRequest.upload 对象属性上没有注册任何事件监听器；也就是说，给定一个 XMLHttpRequest 实例 xhr，没有调用 xhr.upload.addEventListener()，以监听该上传请求。</li><li>请求中没有使用 ReadableStream 对象。</li></ol><h1 id="需要注意的头部"><a class="header-anchor" href="#需要注意的头部">#</a>需要注意的头部</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Access-Control-Allow-Origin:</span> <span class="string">https://foo.example</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Methods:</span> <span class="string">POST,</span> <span class="string">GET,</span> <span class="string">OPTIONS</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Headers:</span> <span class="string">X-PINGOTHER,</span> <span class="string">Content-Type</span></span><br><span class="line"><span class="attr">Access-Control-Max-Age:</span> <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>。。应该能轻松看懂吧。<br>这是在后端服务器上设置的头部，在CORS请求中的响应头中返回的字段，用于CORS的安全策略。<br>包括设置了允许访问的源，允许访问的方式，请求头中允许设置的头部字段，预检请求可以缓存时间从长短（单位秒）。</p><h1 id="fetch"><a class="header-anchor" href="#fetch">#</a>fetch</h1><p>是的，fetch的访问也会受到cors的限制，与简单请求有一定的相关。可以多注意一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;首先，这篇是从&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS?qs=co</summary>
      
    
    
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="cors" scheme="http://localhost:5000/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>任务，微任务，事件循环以及js运行时理论篇</title>
    <link href="http://localhost:5000/2022/11/30/js-runtime/"/>
    <id>http://localhost:5000/2022/11/30/js-runtime/</id>
    <published>2022-11-30T07:21:29.000Z</published>
    <updated>2022-11-30T14:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景">#</a>背景</h1><p>宏任务和微任务是前端八股重要一问。<br>答案就是宏任务在微任务之前。<br>但到底是怎么一回事呢？<br>当然可以直接去看<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">In depth: Microtasks and the JavaScript runtime environment</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a><br>我也不过是从中总结而已。</p><h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1><p>在MDN中，在下只找到了一处使用<code>宏任务</code>这个词的地方。<br>就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a>，里面使用括号标注了<code>宏任务</code>这个词。<br>而在英文，以及大部分的中文翻译中，都只是用了<code>task</code>或者<code>任务</code>这个词。</p><h1 id="第一核心问题"><a class="header-anchor" href="#第一核心问题">#</a>第一核心问题</h1><p>第一核心问题，当然是什么是任务和微任务。<br>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a>中有解答。</p><ul><li>任务：一个 任务 就是由执行诸如从头执行一段程序、执行一个事件回调或一个 interval/timeout 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 任务队列（task queue）上被调度。</li><li>微任务：一个 微任务（microtask）就是一个简短的函数，当创建该函数的函数执行之后，并且 只有当 Javascript 调用栈为空，而控制权尚未返还给被 user agent 用来驱动脚本执行环境的事件循环之前，该微任务才会被执行。</li></ul><p>是不是一头雾水？那换一种说法，也是八股常考，如何触发任务和微任务。</p><p>任务触发：</p><ol><li>一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 script 元素中运行代码）。</li><li>触发了一个事件，将其回调函数添加到任务队列时。</li><li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时。</li></ol><p>微任务触发：<br>JavaScript 中的 promises 和 Mutation Observer API 都使用微任务队列去运行它们的回调函数，但当能够推迟工作直到当前事件循环过程完结时，也是可以执行微任务的时机。为了允许第三方库、框架、polyfills 能使用微任务，Window 暴露了 queueMicrotask() 方法，而 Worker 接口则通过 WindowOrWorkerGlobalScope mixin 提供了同名的 queueMicrotask() 方法。</p><blockquote><p>也就是promises、Mutation Observer API和queueMicrotask。</p></blockquote><h1 id="什么是事件循环"><a class="header-anchor" href="#什么是事件循环">#</a>什么是事件循环</h1><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a>有解答。</p><p>每个代理都是由事件循环驱动的，事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务，然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p><p>网页或者 app 的代码和浏览器本身的用户界面程序运行在相同的 线程中，共享相同的 事件循环。该线程就是 主线程，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。</p><p>然后，事件循环会驱动发生在浏览器中与用户交互有关的一切，但在这里，对我们来说更重要的是需要了解它是如何负责调度和执行在其线程中执行的每段代码的。</p><p>有如下三种事件循环：</p><ol><li>Window 事件循环</li></ol><blockquote><p>window 事件循环驱动所有同源的窗口 (though there are further limits to this as described elsewhere in this article XXXX ???).</p></blockquote><ol start="2"><li>Worker 事件循环</li></ol><blockquote><p>worker 事件循环顾名思义就是驱动 worker 的事件循环。这包括了所有种类的 worker：最基本的 web worker 以及 shared worker 和 service worker。Worker 被放在一个或多个独立于“主代码”的代理中。浏览器可能会用单个或多个事件循环来处理给定类型的所有 worker。</p></blockquote><ol start="3"><li>Worklet 事件循环</li></ol><blockquote><p>worklet (en-US) 事件循环用于驱动运行 worklet 的代理。这包含了 Worklet (en-US)、AudioWorklet (en-US) 以及 PaintWorklet (en-US)。</p></blockquote><p>多个同源（译者注：此处同源的源应该不是指同源策略中的源，而是指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等，意味着起源的意思，下一段内容就会对这里进行说明）窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。记住这里的网络术语“window”实际上指的用于运行网页内容的浏览器级容器，包括实际的 window，一个 tab 标签或者一个 frame。</p><p>在特定情况下，同源窗口之间共享事件循环，例如：</p><p>如果一个窗口打开了另一个窗口，它们可能会共享一个事件循环。<br>如果窗口是包含在 iframe 中，则它可能会和包含它的窗口共享一个事件循环。<br>在多进程浏览器中多个窗口碰巧共享了同一个进程。<br>这种特定情况依赖于浏览器的具体实现，各个浏览器可能并不一样。</p><p>总结：<br>事件循环线程就是主线程。至于背地里做的那些事，由浏览器安排。<br>事件循环线程的流程：</p><ol><li>收集事件（包括用户事件以及其他非用户事件等）</li><li>对任务进行排队以便在合适的时候执行回调</li><li>执行所有处于等待中的 JavaScript 任务</li><li>执行所有处于等待中的 JavaScript 微任务</li><li>执行一些必要的渲染和绘制操作</li></ol><h1 id="任务和微任务的先后"><a class="header-anchor" href="#任务和微任务的先后">#</a>任务和微任务的先后</h1><p>。。简单的话，事件循环已经解答了。<br>在一次事件循环中，先执行任务，再执行微任务。<br>至于细节一点。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a>里讲。</p><p>首先，每当一个任务存在，事件循环都会检查该任务是否正把控制权交给其他 JavaScript 代码。如若不然，事件循环就会运行微任务队列中的所有微任务。<br>其次，如果一个微任务通过调用 queueMicrotask(), 向队列中加入了更多的微任务，则那些新加入的微任务 会早于下一个任务运行。这是因为事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。</p><h1 id="最后"><a class="header-anchor" href="#最后">#</a>最后</h1><p>上面说的是真的吗？<br>不过是MDN中讲的罢了。<br>还需要真正用代码来验证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;#&lt;/a&gt;背景&lt;/h1&gt;
&lt;p&gt;宏任务和微任务是前端八股重要一问。&lt;br&gt;
答案就是宏任务在微任务之前。&lt;br&gt;
但到底是怎么一回事呢？&lt;br&gt;
当然可以直接去看&lt;br&gt;
&lt;a hre</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="eventLoop" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/eventLoop/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="eventLoop" scheme="http://localhost:5000/tags/eventLoop/"/>
    
    <category term="js-runtime" scheme="http://localhost:5000/tags/js-runtime/"/>
    
    <category term="microtask" scheme="http://localhost:5000/tags/microtask/"/>
    
  </entry>
  
  <entry>
    <title>flask-tutorial</title>
    <link href="http://localhost:5000/2022/11/29/flask-tutorial/"/>
    <id>http://localhost:5000/2022/11/29/flask-tutorial/</id>
    <published>2022-11-29T05:14:23.000Z</published>
    <updated>2022-11-30T07:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a class="header-anchor" href="#起因">#</a>起因</h1><p>最近简单看了flask的文档。<br>然后把里面<a href="https://dormousehole.readthedocs.io/en/latest/tutorial/index.html">教程</a>的那一章敲了一遍。<br>敲完的代码放到了<a href="https://github.com/el-psy/flask-tutorial">这里</a>。<br>但是只是浮光掠影，对于flask还是不甚了解。<br>所以准备将这些代码中不懂的部分简单总结一下。虽然总结之后还是不懂，但总是方便查找了。</p><h1 id="概括"><a class="header-anchor" href="#概括">#</a>概括</h1><p>flask大概就是通过装饰器装饰函数，使用url调用该函数，返回值可以通过模板的方式合成html页面。<br>至于项目。<br>可以分为4个部分：</p><ul><li><code>__init__.py</code>主体部分。包括配置引入。</li><li><code>auth.py</code>认证部分。包括登录注册注销，以及一个装饰器，用于那些需要登录才能访问的url。</li><li><code>db.py</code>数据部分。包括连接数据库，初始化数据库，关闭数据库连接之类的。</li><li><code>blog.py</code>blog部分。主要功能所在。包括增加修改删除功能。</li></ul><h1 id="init"><a class="header-anchor" href="#init">#</a>__init__</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>(<span class="params">test_config=<span class="literal">None</span></span>):</span><br><span class="line">app = Flask(__name__, instance_relative_config = <span class="literal">True</span>)</span><br><span class="line">app.config.from_mapping(</span><br><span class="line">SECRET_KEY = <span class="string">&#x27;dev&#x27;</span>,</span><br><span class="line">DATABASE = os.path.join(app.instance_path, <span class="string">&#x27;flask.sqlite&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> test_config <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">app.config.from_pyfile(<span class="string">&#x27;config.py&#x27;</span>, silent = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">app.config.from_mapping(test_config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">os.makedirs(app.instance_path)</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> db</span><br><span class="line">db.init_app(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> auth</span><br><span class="line">app.register_blueprint(auth.bp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> blog</span><br><span class="line">app.register_blueprint(blog.bp)</span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/&#x27;</span>, endpoint=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><ol><li><code>instance_relative_config</code></li></ol><blockquote><p>配置文件路径相关。默认是“相对于应用的根目录”，这个值为<code>True</code>的时候为“相对于实例文件夹”。</p></blockquote><ol start="2"><li>SECRET_KEY</li></ol><blockquote><p>说是秘钥，但也没有明显发现其他代码哪里用到了。或许是<code>auth.py</code>中的<code>generate_password_hash</code>之类的？</p></blockquote><ol start="3"><li>DATABASE</li></ol><blockquote><p>数据库文件路径。在<code>db.py</code>中使用。</p></blockquote><ol start="4"><li>app.add_url_rule</li></ol><blockquote><p>完全看不懂</p></blockquote><h1 id="db"><a class="header-anchor" href="#db">#</a>db</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app, g</span><br><span class="line"><span class="keyword">from</span> flask.cli <span class="keyword">import</span> with_appcontext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_db</span>():</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;db&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">g.db = sqlite3.connect(</span><br><span class="line">current_app.config[<span class="string">&#x27;DATABASE&#x27;</span>],</span><br><span class="line">detect_types=sqlite3.PARSE_DECLTYPES</span><br><span class="line">)</span><br><span class="line">g.db.row_factory = sqlite3.Row</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> g.db</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close_db</span>(<span class="params">e=<span class="literal">None</span></span>):</span><br><span class="line">db = g.pop(<span class="string">&#x27;db&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> db <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db</span>():</span><br><span class="line">db = get_db()</span><br><span class="line"><span class="keyword">with</span> current_app.open_resource(<span class="string">&#x27;schema.sql&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">db.executescript(f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command(<span class="params"><span class="string">&#x27;init-db&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@with_appcontext</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db_command</span>():</span><br><span class="line">init_db()</span><br><span class="line">click.echo(<span class="string">&#x27;Initialized the database.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_app</span>(<span class="params">app</span>):</span><br><span class="line">app.teardown_appcontext(close_db)</span><br><span class="line">app.cli.add_command(init_db_command)</span><br></pre></td></tr></table></figure><ol><li>current_app</li></ol><blockquote><p>类型是LocalProxy<br>像全局变量一样工作，但只能在处理请求期间且在处理它的线程中访问<br>返回的栈顶元素不是应用上下文，而是flask的应用实例对象<br>Flask 应用对象app具有config的属性，这些属性对于在视图或者在命令调试中访问很方便。但是现在项目的模块导入app 实例会容易出现循环导入的问题<br>Flask 通过应用情景解决了这个问题，不是直接引用一个app，而是使用current_app 代理，该代理指向处理当前活动的应用；<br>至于到底是什么我也不知道。。。感谢百度。</p></blockquote><ol start="2"><li>g</li></ol><blockquote><p>flask的全局变量</p></blockquote><ol start="3"><li>g.db.row_factory = sqlite3.Row</li></ol><blockquote><p>这样查询会返回 Row 对象，而不是字典。 Row 对象是 namedtuple ，因 此既可以通过索引访问也以通过键访问。</p></blockquote><ol start="4"><li>current_app.open_resource</li></ol><blockquote><p>打开文件。相对于应用的相对路径。在<code>__init__.py</code>中设置过。</p></blockquote><ol start="5"><li>with_appcontext</li></ol><blockquote><p>包装回调，以确保它能够与脚本的应用程序上下文一起执行。如果回调直接注册到app.cli对象，则默认情况下，除非禁用此函数，否则将使用此函数包装回调。</p></blockquote><ol start="6"><li>app.teardown_appcontext</li></ol><blockquote><p>注册应用程序上下文结束时要调用的函数。当弹出请求上下文时，通常也会调用这些函数。</p></blockquote><ol start="7"><li>init_app</li></ol><blockquote><p>最终注册的函数。</p></blockquote><h1 id="auth"><a class="header-anchor" href="#auth">#</a>auth</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp = Blueprint(<span class="string">&#x27;auth&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/auth&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>所谓的蓝图</li></ol><blockquote><p>name=“auth” 蓝图的名称。将在每个端点名称前加上前缀。<br>import_name=__name__ 蓝图包的名称，通常为__name__。这有助于定位蓝图的root_path。<br>url_prefix=&quot;/auth&quot; 一个路径，用于在蓝图的所有URL前加上前缀，使其与应用程序的其他路径不同。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/register&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span> :</span><br><span class="line">username = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">db = get_db()</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">error = <span class="string">&#x27;Username is required.&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> password:</span><br><span class="line">error = <span class="string">&#x27;Password is required.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;insert into user (username, password) values (?, ?)&#x27;</span>,</span><br><span class="line">(username, generate_password_hash(password)),</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">except</span> db.IntegrityError:</span><br><span class="line">error = <span class="string">f&quot;User <span class="subst">&#123;username&#125;</span> is already registered.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.login&#x27;</span>))</span><br><span class="line">flash(error)</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;auth/register.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>request</li></ol><blockquote><p>请求体。试试文档api中的<code>Incoming Request Data</code>？</p></blockquote><ol start="2"><li>db.execute</li></ol><blockquote><p>会进行字符串转换的。。</p></blockquote><ol start="3"><li>generate_password_hash</li></ol><blockquote><p>加密</p></blockquote><ol start="4"><li>flash</li></ol><blockquote><p>所谓的error提示。其实会在模板中会有体现。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">username = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">db = get_db()</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line">user = db.execute(</span><br><span class="line"><span class="string">&#x27;select * from user where username = ?&#x27;</span>,</span><br><span class="line">(username,)</span><br><span class="line">).fetchone()</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">error = <span class="string">&#x27;Incorrect username.&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> check_password_hash(user[<span class="string">&#x27;password&#x27;</span>], password):</span><br><span class="line">error = <span class="string">&#x27;Incorrect password.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">session.clear()</span><br><span class="line">session[<span class="string">&#x27;user_id&#x27;</span>] = user[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br><span class="line"></span><br><span class="line">flash(error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;auth/login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>check_password_hash</li></ol><blockquote><p>验证加密。</p></blockquote><ol start="2"><li>session</li></ol><blockquote><p>session和cookie的作用有点类似，都是为了存储用户相关的信息的，区别在于 session 是保存在服务器端的，用 session_id 来标识用户。而 cookie 是保存在客户端，session 的出现，是为了解决 cookie 存储数据不安全的问题的。<br>flask中的session机制是：把敏感数据经过加密后放入session中，然后再把session存放到cookie中，下次请求的时候，再从浏览器发送过来的cookie中读取session，然后再从session中读取敏感数据，并进行解密，获取最终的用户数据。<br>使用session需要设置SECRET_KEY</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.before_app_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_logged_in_user</span>():</span><br><span class="line">user_id = session.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> user_id <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">g.user = <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">g.user = get_db().execute(</span><br><span class="line"><span class="string">&#x27;select * from user where id = ?&#x27;</span>,</span><br><span class="line">(user_id,)</span><br><span class="line">).fetchone()</span><br></pre></td></tr></table></figure><ol><li>before_app_request</li></ol><blockquote><p>这样的函数在每次请求之前执行，即使在蓝图之外。</p></blockquote><ol start="2"><li>g</li></ol><blockquote><p>别问我为什么需要将user数据设置在g里。我也不知道。。。<br>2.1. 生命周期<br>请求过来创建，请求结束销毁；<br>仅适用于单次请求，g的生命周期即一个请求的生命周期<br>注：和session不同，session是多个请求都可以使用的<br>2.2. g是什么<br>g相当于单次请求中的“全局变量”，能在单词请求中调用，但是和其他请求是互相隔离的<br>可以参考上下文管理部分，g的创建与销毁流程理解<br>2.3. g能做什么<br>可以在单次请求中定义一些值和操作，随着本次请求结束而销毁；<br>如，权限管理</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/logout&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>():</span><br><span class="line">session.clear()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br></pre></td></tr></table></figure><ol><li>session.clear()</li></ol><blockquote><p>清空session。cookie也随之清空。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">view</span>):</span><br><span class="line"><span class="meta">@functools.wraps(<span class="params">view</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapped_view</span>(<span class="params">**kwargs</span>):</span><br><span class="line"><span class="keyword">if</span> g.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.login&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> view(**kwargs)</span><br><span class="line"><span class="keyword">return</span> wrapped_view</span><br></pre></td></tr></table></figure><ol><li>functools.wraps</li></ol><blockquote><p>首先这是一个装饰器，用于需要经过验证才能访问的url的。<br>标准库 functools 中的 wrap 函数用于包装函数, 不改变原有函数的功能, 仅改变原有函数的一些属性, 例如 __name__, __doc__, __annotations__ 等属性<br>我也不知道在这里使用到底有什么用。。</p></blockquote><h1 id="blog"><a class="header-anchor" href="#blog">#</a>blog</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> ( Blueprint, flash, g, redirect, render_template, request, url_for )</span><br><span class="line"><span class="keyword">from</span> werkzeug.exceptions <span class="keyword">import</span> abort</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flaskr.auth <span class="keyword">import</span> login_required</span><br><span class="line"><span class="keyword">from</span> flaskr.db <span class="keyword">import</span> get_db</span><br><span class="line"></span><br><span class="line">bp = Blueprint(<span class="string">&#x27;blog&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">db = get_db()</span><br><span class="line">posts = db.execute(</span><br><span class="line"><span class="string">&#x27;select p.id, title, body, created, author_id, username from post p join user u on p.author_id = u.id order by created desc&#x27;</span></span><br><span class="line">).fetchall()</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;blog/index.html&#x27;</span>, posts = posts)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/create&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>():</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">title = request.form[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">body = request.form[<span class="string">&#x27;body&#x27;</span>]</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> title:</span><br><span class="line">error = <span class="string">&#x27;Title is required.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">flash(error)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">db = get_db()</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;insert into post (title, body, author_id) values (?,?,?)&#x27;</span>,</span><br><span class="line">(title, body, g.user[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;blog.index&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;blog/create.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params"><span class="built_in">id</span>, check_author = <span class="literal">True</span></span>):</span><br><span class="line">post = get_db().execute(</span><br><span class="line"><span class="string">&#x27;select p.id, title, body, created, author_id, username from post p join user u on p.author_id = u.id where p.id = ?&#x27;</span>,</span><br><span class="line">(<span class="built_in">id</span>,)</span><br><span class="line">).fetchone()</span><br><span class="line"><span class="keyword">if</span> post <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">abort(<span class="number">404</span>, <span class="string">f&#x27;Post id <span class="subst">&#123;<span class="built_in">id</span>&#125;</span> doesn\&#x27;t exist.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> check_author <span class="keyword">and</span> post[<span class="string">&#x27;author_id&#x27;</span>] != g.user[<span class="string">&#x27;id&#x27;</span>]:</span><br><span class="line">abort(<span class="number">403</span>)</span><br><span class="line"><span class="keyword">return</span> post</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/&lt;int:id&gt;/update&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">post = get_post(<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">title = request.form[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">body = request.form[<span class="string">&#x27;body&#x27;</span>]</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> title:</span><br><span class="line">error = <span class="string">&#x27;Title is required.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">flash(error)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">db = get_db()</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;update post set title = ?, body = ? where id = ?&#x27;</span>,</span><br><span class="line">(title, body, <span class="built_in">id</span>)</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;blog.index&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;blog/update.html&#x27;</span>, post = post)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/&lt;int:id&gt;/delete&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">get_post(<span class="built_in">id</span>)</span><br><span class="line">db = get_db()</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;delete from post where id = ?&#x27;</span>, (<span class="built_in">id</span>,)</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;blog.index&#x27;</span>))</span><br></pre></td></tr></table></figure><p>最后的blog.py并没有什么要讲的。就是简单的crud。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起因&quot;&gt;#&lt;/a&gt;起因&lt;/h1&gt;
&lt;p&gt;最近简单看了flask的文档。&lt;br&gt;
然后把里面&lt;a href=&quot;https://dormousehole.readthedocs.io/en/lat</summary>
      
    
    
    
    <category term="后端" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/flask/"/>
    
    
    <category term="后端" scheme="http://localhost:5000/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>Pattern: Backends For Frontends 翻译尝试</title>
    <link href="http://localhost:5000/2022/11/24/frontend-bff-1/"/>
    <id>http://localhost:5000/2022/11/24/frontend-bff-1/</id>
    <published>2022-11-23T15:44:28.000Z</published>
    <updated>2022-11-25T09:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pattern: Backends For Frontends</p><h1 id="模式：backends-for-frontends"><a class="header-anchor" href="#模式：backends-for-frontends">#</a>模式：Backends For Frontends</h1><p>Written on Nov 18 2015<br>写于 2015.11.18<br>Single-purpose Edge Services for UIs and external parties<br>针对UI和外部的单一目标的边缘服务</p><p>Introduction</p><h1 id="介绍"><a class="header-anchor" href="#介绍">#</a>介绍</h1><p>With the advent and success of the web, the de facto way of delivering user interfaces has shifted from thick-client applications to interfaces delivered via the web, a trend that has also enabled the growth of SAAS-based solutions in general. The benefits of delivering a user interface over the web were huge - primarily as the cost of releasing new functionality was significantly reduced as the cost of client-side installs was (in most cases) eliminated altogether.<br>随着web技术出现并取得成功，与用户的交互已经从厚重的客户端转向通过web界面，这一趋势也推动了基于SAAS的方案的增长。使用web界面与用户交互的好处是巨大的————主要是由于发布新功能的成本显著降低，大多数情况下客户端安装的成本被完全消除。</p><p>This simpler world didn’t last long though, as the age of the mobile followed shortly afterwards. Now we had a problem. We had server-side functionality which we wanted to expose both via our desktop web UI, and via one or more mobile UIs. With a system that had initially been developed with a desktop-web UI in mind, we often faced a problem in accommodating these new types of user interface, often as we already had a tight coupling between the desktop web UI and our backed services.<br>然而随着移动时代的到来，这个简单的世界并没有持续多久。现在我们遇到了一个问题：我们希望通过web端的UI和移动端的UI调用服务端的功能，但是在最初考虑到桌面端UI的系统的时候，我们发现桌面端UI与服务端的接口之间已经紧密耦合。</p><p>The General-Purpose API Backend</p><h1 id="通用api后端"><a class="header-anchor" href="#通用api后端">#</a>通用API后端</h1><p>A first step in accommodating more than one type of UI is normally to provide a single, server-side API, and add more functionality as required over time to support new types of mobile interaction:<br>适应多种UI的第一步通常是提供单一的服务端API，并根据需求添加更多功能，以支持新类型的移动交互<br><img src="./single-api.jpg" alt="" title="通用API后端"></p><figcaption>通用API后端</figcaption><p>If these different UIs want to make the same or very similar sorts of calls, then it can be easy for this sort of general-purpose API to be successful. However the nature of a mobile experience often differs drastically from a desktop web experience. Firstly, the affordances of a mobile device are very different. We have less screen real estate, which means we can display less data. Opening lots of connections to server-side resources can drain battery life and limited data plans. And secondly, the nature of the interactions we want to provide on a mobile device can differ drastically. Think of a typical bricks-and-mortar retailer. On a desktop app I might allow you to look at the items for sale, order online or reserve in store. On the mobile device though I might want to allow you scan bar codes to do price comparisons or give you context-based offers while in store. As we’ve built more and more mobile applications we’ve come to realise that people use them very differently and therefore the functionality we need to expose will differ too.<br>如果这些不同的UI想要有相同的或相似的调用，那么这种通用API很容易成功。然而，移动端和桌面端的体验本质上截然不同。首先，移动端UI的可利用资源与桌面端截然不同。我们有更少的屏幕空间，这意味着我们只能显示更少的数据；向服务器发送大量请求可能会消耗电池寿命和电池电量。其次，我们希望在移动端提供的用户交互会有很大不同。比如典型的实体零售商。在桌面端，我们可能会允许用户查看待售商品、在线订购和在商店预定。但在移动端，我可能会让用户扫描条形码进行价格比较，或者在商店里基于用户历史习惯提供内容。随着我们构建了越来越多的移动应用程序，我们开始意识到用户使用它们的方式非常不同，因此我们需要提供的功能（提供的接口？）也会有所不同。</p><p>So in practice, our mobile devices will want to make different calls, fewer calls, and will want to display different (and probably less) data than their desktop counterparts. This means that we need to add additional functionality to our API backend to support our mobile interfaces.<br>因此，在实践中，我们的移动端希望有不同的请求，更少的请求，与桌面端相比展示不同（一般情况下是更少）的数据。这意味着我们需要在后端API添加额外的功能，支持我们的移动端。</p><p>Another problem with the general-purpose API backend is that they are by definition providing functionality to multiple, user-facing applications. This means that the single API backend can become a bottleneck when rolling out new delivery, as so many changes are trying to be made to the same deployable artifact.<br>通用API后端的另一个问题是，它为不同用户界面提供功能。这意味着，单一的后端API成为了瓶颈，当提供新的功能交付时，对一个可部署工件会做许多更改。</p><p>The tendency for the general-purpose API backend to take on multiple responsibilities, and therefore require lots of work, often results in a team being created specifically to handle this code base. This can make the problem much worse, as now front-end teams have to interface with a separate team to get changes made - a team which will have to balance both the priorities of the different client teams, and also work with multiple downstream teams to consume new APIs as they become available. It could be argued that at this point we have just created a smart-piece of middleware in our architecture, something which is not focused on any particular business domain - something which goes against many people’s views of what sensible Service Oriented Architecture should look like.<br>随着通用后端API承担越来越多的功能，会产生大量工作需求，结果就是需要专门创建一个团队来管理后端代码。这可能会导致问题变得更糟：现在前端团队会为了需求更改与另一个团队（后端）来进行沟通————而后端团队也必须平衡多种不同客户端之间的需求，并且与多个下游团队合作，创建新的可用API。就这样我们创建了一个智能的中间件，但是它没有专注于任何特定的业务领域，与人们对于面向服务的智能体系架构的想法相违背。</p><p><img src="general-purpose-api-teams.jpg" alt="" title="使用通用支持API时的通用团队结构"></p><figcaption>使用通用支持API时的通用团队结构</figcaption><p>Introducing The Backend For Frontend<br>Backend For Frontend介绍</p><p>One solution to this problem that I have seen in use at both REA and SoundCloud is that rather than have a general-purpose API backend, instead you have one backend per user experience - or as (ex-SoundClouder) Phil Calçado called it a Backend For Frontend (BFF). Conceptually, you should think of the user-facing application as being two components - a client-side application living outside your perimeter, and a server-side component (the BFF) inside your perimeter.<br>我在REA和SoundCloud看到的这个问题的一个解决方案就是，为每一个用户UI创建一个后端，取消原来的通用后端API————这被一位前SoundClouder Phil Calçado成为Backend For Frontend (BFF)。从概念上讲，应当将面向用户的应用程序分为两个组件————一个是在外的客户端应用程序，一个是在内的服务端组件（BFF）。</p><p>The BFF is tightly coupled to a specific user experience, and will typically be maintained by the same team as the user interface, thereby making it easier to define and adapt the API as the UI requires, while also simplifying process of lining up release of both the client and server components.<br>BFF与特定的用户UI紧密耦合，通常由构建用户界面的团队进行维护，从而使得根据UI的需求定制调整API变得更加容易，同时也简化了客户端和服务器组件的发布流程。<br><img src="bff-overview.jpg" alt="" title="每一个用户界面使用一个服务端的BFF"></p><figcaption>每一个用户界面使用一个服务端的BFF</figcaption><p>BFF专注于一个单独的UI，这使得它能够被定制化，从而变得更小型化。</p><p>How Many BFFs?<br>我们需要多少个BFF？</p><p>当谈到为不同平台提供相同（或相似）的用户体验时，我看到了两种不同的方案。我更喜欢的模型是阉割为每种不同的客户端提供一个BFF————这是我在REA看到的一个模型：<br><img src="one-bff-per-mobile.jpg" alt="" title="不同的移动平台，不同的BFF，在REA中"></p><figcaption>不同的移动平台，不同的BFF，在REA中</figcaption><p>The other model, which I have seen in use at SoundCloud, uses one BFF per type of user interface. So both the Android and iOS versions of the listener native application use the same BFF:<br>另一种模型，就像我在SoundCloud看到的，为每种类型的用户界面创建一个BFF。所以Android和iOS使用了同一个移动端的BFF：<br><img src="generic-mobile-bff.jpg" alt="" title="为不同的移动端创建一个BFF，在SoundCloud中"></p><figcaption>为不同的移动端创建一个BFF，在SoundCloud中</figcaption><p>My main concern with the second model is just that the more types of clients you have using a single BFF, the more temptation there may be for it to become bloated by handling multiple concerns. The key thing to understand here though is that even when sharing a BFF, it is for the same class of user interface - so while SoundCloud’s listener Native applications for both iOS and Android use the same BFF, other native applications would use different BFFs (for example the new Creator application Pulse uses a different BFF). I’m also more relaxed about using this model if the same team owns both the Android and iOS applications and own the BFF too - if these applications are maintained by different teams, I’m more inclined to recommend the more strict model. So you can see your organisation structure as being one of the main drivers to which model makes the most sense (Conway’s Law wins again). It’s worth noting that the SoundCloud engineers I spoke to suggested that having one BFF for both Android and iOS listener applications was something they might reconsider if making the decision again today.<br>我对于第二个模型的主要担忧是，随着使用单一BFF的客户端类型越多，处理多种请求可能会导致体积臃肿。这里需要理解的关键是，即使共享同一个BFF，它也适用于同一类用户界面————因此当SoundCloud的侦听器侦听到Android和iOS的客户端时，会调用移动端的BFF；侦听到其他类型的客户端时，会调用其他的BFF（例如新出的应用Pulse使用了不同的BFF）。如果是由同一个团队负责Android和iOS的客户端以及对应的BFF时，我也更乐于使用第二种模式————反之，如果是由不同的团队分别负责，我更倾向于更严格的第一种模式。因此，你可以将你的组织架构思维模型选择的主要驱动因素之一（康威定律再次获胜）。值得一提的是，当年我口中说的为Android和iOS的客户端提供一个BFF的SoundCloud工程师说，如果是今日再选择BFF可能会重新考虑方案（或许是与往日不同的组织架构？）。</p><p>One guideline that I really like from Stewart Gleadow (who in turn credited Phil Calçado and Mustafa Sezgin) was ‘one experience, one BFF’. So if the iOS and Android experiences are very similar, then it is easier to justify having a single BFF. If however they diverge greatly, then having separate BFFs makes more sense.<br>我非常喜欢Stewart Gleadow（他反过来称赞Phil Calçado和Mustafa Sezgin）的一条指导原则，“一种体验，一个BFF”。因此，如果iOS和Android的用户体验非常相似，那么更容易证明拥有一个BFF是合理的。反之，如果两者的用户体验分歧巨大，那么拥有单独的BFF更合理。</p><p>Pete Hodgson made the observation that BFFs work best when aligned around team boundaries, so team structure should drive how many BFFs you have. So that if you have a single mobile team, you should have one BFF, but if you had separate iOS and Android teams, you’d have separate BFFs. My concern is that team structures tend to be more fluid than our system design. So if you have a single BFF for mobile, then split the team into iOS and Android specialisations, do you then have to split the BFF too? If the BFFs were already separate, then splitting the team would be easier as you can reassign ownership of the already independent asset. The interplay of BFF and team structure is important though, something we’ll explore more shortly.<br>Pete Hodgson观察到，围绕团队架构来构建BFF时BFF的工作情况最佳，因此团队结构决定你应构建多少BFF。因此，如果你有一个单一的移动端团队，应该为此构建一个BFF；如果有分开的Android和iOS团队，应该为之分别构建BFF。我担心的是，团队结构往往比我们的系统架构设计更具流动性。所以，当你的单独的移动端团队被分割成Android和iOS两个团队时，是否也必须拆分BFF？如果BFF已经拆分，那么拆分软对将更容易，因为你可以重新分配独立资产的所有权。BFF和团队结构之间的相互作用很重要，我们稍后会对此进行深入探讨。</p><p>Often the driver towards having a smaller number of BFFs is around reusing server-side functionality to avoid too much duplication, but there are other ways to handle this which we’ll cover shortly.<br>通常，占驱动因素较小比重的是重用服务端功能，避免过多的冗余。但这里还有其他方案解决这一问题，我们将很快介绍。</p><p>And Multiple Downstream Services (Microservices!)</p><h1 id="以及多个下游服务-微服务"><a class="header-anchor" href="#以及多个下游服务-微服务">#</a>以及多个下游服务（微服务！）</h1><p>BFFs can be a useful pattern for architectures where there are a small number of backend services. For organisations using a large number of services however they can be essential, as the need to aggregate multiple downstream calls to deliver user functionality increases drastically. In such situations it will be common for a single call in to a BFF to result in multiple downstream calls to microservices. For example, imagine an application for an e-commerce company. We want to pull back a list of items in a user’s wish list, displaying stock levels, and price:<br>BFF对于后端服务较少的架构来说是一种可选的模式。但是对于提供大量服务的组织来说，由于聚合多个下游调用以提供用户功能的需求急剧增加，BFF是必不可少的。在这种情况下，对BFF的单个调用，会导致对微服务的多个下游调用。例如，想象一个电子商务公司的应用程序。我们希望返回一个用户的愿望清单，显示库存水平和价格：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>The Brakes - Give Blood</td><td>In Stock! (14 items remaining)</td><td>$5.99</td><td>order now</td></tr><tr><td>Blue Juice - Retrospectable</td><td>Out Of Stock</td><td>$17.50</td><td>pre order</td></tr><tr><td>Hot Chip - Why Make Sense?</td><td>Going fast (2 items left)</td><td>$9.99</td><td>order now</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Brakes - Give Blood</td><td>现货! (14件剩余)</td><td>$5.99</td><td>下单</td></tr><tr><td>蓝汁 - Retrospectable</td><td>售空</td><td>$17.50</td><td>预定</td></tr><tr><td>Hot Chip - Why Make Sense?</td><td>库存量少 (2件剩余)</td><td>$9.99</td><td>下单</td></tr></tbody></table><p>其实三项都是音乐专辑。。</p><p>Multiple services hold the pieces of information we want. The Wishlist service stores information about the list, and IDs of each item. The Catalog service stores the name and price of each item, and the Stock levels are stored in our inventory service. So in our BFF we’d expose a method for retrieving the full playlist, which would consist of at least 3 calls:<br>一个服务只包含我们需要的部分信息。其中，Wishlist服务存储清单的信息以及每件商品的ID，Catalog服务存储每件商品的名称和价格，Stock服务存储了库存数量信息。所以，在我们的BFF中，将创建一个检索完整播放列表的方法，该方法至少包含三个调用：</p><p><img src="sequence.jpg" alt="" title="构建愿望清单，需要调用多个下游服务"></p><figcaption>构建愿望清单，需要调用多个下游服务</figcaption><p>From an efficiency point of view, it would be much smarter to run as many calls in parallel as possible. Once the initial call to the Wishlist service completes, ideally we’d like to then run the calls to the other services at the same time to reduce the overall call time. This need to mix calls that we want to run in parallel vs those that run in sequence can quickly become painful to manage, especially for more complex scenarios. This is one area where a reactive style of programming can help (such as that provided by RxJava or Finagle’s futures system) as the composition of multiple calls becomes easier to manage.<br>从效率的角度来看，尽可能多地并行调用会更好。所以，一旦Wishlist服务调用完成，我们应立即调用剩余所有的服务。这种需要并行调用和顺序调用的方式混合，可能会使得代码变得难以管理，尤其是对于更复杂的场景。这就是一个反应式编程风格可以解决的领域（例如RxJava或Finagle的期货系统提供的编程风格），这种方式可以使多个调用的组合变得容易管理。</p><p>Failure modes though become important to understand. In our example above, we could insist that all downstream calls have to return in order for us to return a payload to our client. However is this sensible? Obviously we can’t do anything if the Wishlist service is down, but if only the Inventory service was down, wouldn’t it be better to just degrade the functionality we pass back to the client, perhaps just by removing the stock level indicator? These concerns have to be managed by the BFF itself in the first instance, but we also need to make sure that the client making the call to the BFF can interpret a partial response and render it correctly.<br>了解故障处理也很重要。在上面的示例中，我们可以假设所有下游调用都必然有返回，以便我们想客户端返回有效内容。然而，这是现实的吗？显然，如果Wishlist服务宕机，我们无计可施，但如果仅有Inventory服务宕机了呢？我们减少返回给客户端的数据不就可以了吗？也许只是删掉库存水平显示功能？这些问题必须由BFF自己管理，但我们还需要确保调用BFF的客户端能够解析返回的不全信息并能够正确显示。</p><p>Reuse and BFFs</p><h1 id="重用和bff"><a class="header-anchor" href="#重用和bff">#</a>重用和BFF</h1><p>One of the concerns of having a single BFF per user interface is that you can end up with lots of duplication between the BFFs themselves. For example they may end up performing the same types of aggregation, have the same or similar code for interfacing with downstream services etc. Some people react to this by wanting to merge these back together, and so have a general-purpose aggregating Edge API service. This model has proven time and again to lead to highly bloated code with multiple concerns squashed together.<br>每个用户界面配一个BFF的问题之一是，BFF之间可能会出现大量冗余。例如，他们最终可能会有相同类型的功能，与下游服务会有相同或类似的代码调用。一些人想要将这些冗余整合，于是诞生了通用目的的边缘API聚合服务模型。这个模型一次又一次证明会导致代码高度臃肿，多个关注点挤在一起。</p><p>As I have said many times before, I am fairly relaxed about duplicated code across services. Which is to say that while in a single process boundary I will typically do whatever I can to refactor out duplication into suitable abstractions, I don’t have the same reaction when confronted by duplication across services. This is mostly as I am often more worried about the potential for extracting shared code to lead to tight coupling between services - something I am more worried about than duplication in general. That said, there are certainly cases where this is warranted.<br>正如之前提及，我对于跨服务之间的代码冗余相当宽松。也就是说，在同一个流程中，我会尽可能将代码冗余抽象重构；但当遇到跨服务之间的冗余时，我就不会这样做。这主要是因为我更担心抽象重构会导致服务之间的紧密耦合，而这令我更加担心。也就是说，在某些情况下，代码冗余是有必要的。</p><p>My colleague Pete Hodgson has pointed out that when you don’t have BFFs, then often the ‘common’ logic ends up being baked into the different clients themselves. Due to the fact that these clients use very different technology stacks, identifying the fact that this duplication is occurring can be difficult. With organisations tending to have a common technology stack for server-side components, having multiple BFFs with duplication may be easier to spot and factor out.<br>我的同事Pete Hodgson指出，当你没有BFF时，经常会为不同的客户端提供一些共同的功能。由于这些客户端使用了非常不同的技术堆栈，因此很难确定这种“共同”存在的事实。随着为服务端提供共同的技术堆栈，拥有多个重复的BFF可能更容易发现排除问题所在。</p><p>When the time does arise to extract shared code, there are two obvious options. The first, which is often cheapest but more fraught, is to extract a shared library of some sort. The reason this can be problematic is that shared libraries are a prime source of coupling, especially when used to generate client-libraries for calling downstream services. Nonetheless there are situations where this feels right - especially when the code being abstracted is purely a concern inside the service.<br>当需要提取共享代码时，有两个明显的选择：一是提取出某种类型的共享库，这通常是成本最低且更令人担忧的。这是因为，这些共享库往往就是耦合的主要来源，尤其是生成用于调用下游服务的客户端库时。尽管如此，在某些情况下是正确的选择，特别当抽取共享代码时一个服务的内部的问题时。</p><p>The other option is to extract out the shared functionality in a new service, which can work well if you can conceptualise the new service has something modeled around the domain in question.<br>另一种选择是提取出一个新服务的共享功能。如果你能够将新服务概念化，那么它可以很好地工作。</p><p>A variation of this approach might be to push aggregation responsibilities to services further downstream. Take the example above where we discussed rendering of a wish list. Let’s imagine we are rendering a wishlist in two places - on Android, iOS Web. Each of our BFFs are making the same three calls:<br>这种选择的一种变体，或许是将公共功能提取出来作为一种下游服务。以上面的例子举例，我们探讨了愿望清单的实现。让我们想象一下，我们需要在Android和iOS两个地方提高愿望清单。我们的每个BFF都进行相同的三个调用：<br><img src="bff-duplication.jpg" alt="" title="多个BFF实现相同的功能"></p><figcaption>多个BFF实现相同的功能</figcaption><p>Instead, we could change the Wishlist service to make the downstream calls for us, thereby simplifying the job for the callers:<br>相反，我们可以更改Wishlist服务，将其作为一种下游服务，从而简化调用：<br><img src="removing-duplication.jpg" alt="" title="将公共功能作为下游服务，消除BFF中的代码冗余"></p><figcaption>将公共功能作为下游服务，消除BFF中的代码冗余</figcaption><p>I have to say that the same code being used in two places wouldn’t necessarily cause me to want to extract out a service in this way, but I’d be certainly considering it if the transaction cost of creating a new service was low enough, or I was using it in more than a couple of places (for example maybe on the desktop web). I think the old adage of creating an abstraction when you’re about to implement something for the 3rd time still feels like a good rule of thumb, even at the service level.<br>我不得不说，仅在两个地方使用冗余代码不一定让我想到以这种方式处理，但如果创建一个新的下游服务的成本足够低，或者我将在多个地方使用它（例如，可能在桌面web上），我肯定会考虑这样做。我认为，即使在你需要第三次实现某个东西时，进行抽象重构仍然是一个很好的经验法则。</p><p>BFFs for Desktop Web and Beyond</p><h1 id="桌面端的bff以及延伸"><a class="header-anchor" href="#桌面端的bff以及延伸">#</a>桌面端的BFF以及延伸</h1><p>You can think of BFFs as just having a use in solving the constraints of mobile devices. The desktop web experience is typically delivered on more powerful devices with better connectivity, where the cost of making multiple downstream calls is manageable. This can allow your web application to make multiple calls directly to downstream services without the need for a BFF.<br>你可以将BFF视为解决移动端的限制条件的良药。桌面web通常功能更加强大，会运行在性能更强的设备商，在这些设备上调用多个下游服务的成本是可控的。这可以允许你的web应用程序直接调用多个下游服务，而无需BFF。</p><p>I have seen situations though where the use of a BFF for the web too can be useful. When you are generating a larger portion of the web UI on the server-side (e.g using server-side templating), a BFF is the obvious place where this can be done. It can also simplify caching somewhat as you can place a reverse proxy in front of the BFF, allowing you to cache the results of aggregated calls (although you have to make sure you set your cache controls accordingly to ensure that the aggregated content’s expiry is as short as the freshest piece of content in the aggregation needs it to be). I’ve seen it used multiple times in fact without calling it a BFF - in fact the general-purpose API backend often grows from such a beast.<br>不过，我也见过在web端使用BFF的情况。当你在服务器端生成大部分web UI的时候（例如使用服务端模板），BFF很明显可以做到这一点。你也可以在BFF前放置一个反向代理，允许你缓存调用的结果（虽然你必须相应地设置缓存空间，确保聚合内容的到期时间和聚合中最新内容所需时间一样短）。实际上，我见过它多次被使用，但没有将其成为BFF–事实上，通用API后端通常是从这样一个庞然大物成长起来的。</p><p>I’ve seen at least one organisation use BFFs for other external parties that need to make calls. Coming back to my perennial example of a music shop, I might expose a BFF to allow 3rd parties to extract royalty payment information, provide Facebook integration or allow streaming to a range of set-top box devices:<br>我至少见过一个组织为第三方的接口调用提供一个BFF。回到我之前提到的音乐商店的例子，我可能hi暴露一个BFF，允许第三方提取版税支付信息，提供Facebook集成，或允许为一系列机顶盒设备提供流服务。<br><img src="3rd-parties.jpg" alt="" title="使用BFF为第三方提供API"></p><figcaption>使用BFF为第三方提供API</figcaption><p>This approach can be especially effective as third-parties often have limited to no ability (or desire) to use or change the API calls they make. With a general-purpose API backend, you may have to keep old versions of the API around just to satisfy a small subset of your outside parties unable to make a change - with BFF this problem is substantially reduced.<br>这种方法相当有效，因为第三方通常无法（或者不希望）使用或修改他们所做的API调用。如果使用通用API后端，您可能不得不保留旧版本的API，以满足一小部分服务于第三方的需要————使用BFF将大大减少这一问题。</p><p>And Autonomy</p><h1 id="分散定律"><a class="header-anchor" href="#分散定律">#</a>分散定律</h1><p>Quite often we see situation where one team is working on a frontend, and a different team is creating the backend services. In general, we’re trying to avoid this by moving to microservices which are aligned around business verticals, but even then there are situations where this is hard to avoid. Firstly, at a certain level of scale or complexity, multiple teams need to get involved. Secondly, the depth of technical skills required to execute a good Android or iOS experience often need specialised teams.<br>我们通常看到这样的情况：一个团队负责前端，另一个团队扶着创建后端服务。一般来说，我们通过构建围绕业务纵向的微服务来试图避免这种情况。但即使如此，也存在难以避免的情况。首先，如果项目达到一定规模和复杂程度，就需要多个团队参与。其次，实现Android或iOS交互体验需要的专业技能需要一支专业的团队。</p><p>So teams building user interfaces are confronted with the situation that they are calling an API which another team is driving, and often than API is evolving while the user interface is being developed. The BFF can help here, especially if it is owned by the team creating the user interface. They evolve the API of the BFF at the same time as creating the front end. They can iterate both quickly. The BFF itself still needs to call the other downstream services, but this can be done without having to interrupt development of the user interface.<br>因此，构建用户界面的团队面临的情况是，他们正在调用另一个团队驱动开发的API，而在开发用户界面的过程中，API往往不断演变。BFF可以在这里提供帮助，特别是如果它是由创建用户界面的团队负责。他们在构建前端的同时，也完善了BFF的API。他们可以快速迭代。BFF本身仍然需要调用其他下游服务，但这可以在不中断用户界面开发的情况下完成。<br><img src="team-ownership.jpg" alt="" title="使用BFF的团队的所有权界限"></p><figcaption>使用BFF的团队的所有权界限</figcaption><p>The other benefit of using a BFF aligned along team boundaries like this is that the team creating the interface can be much more fluid in thinking about where functionality lives. For example they could decide to push functionality on to the server-side to promote reuse in the future and simplify a native mobile application, or to allow for the faster release of new functionality (as you can bypass the app store review processes). This decision is one that can be made by the team in isolation if they own both the mobile application and the BFF - it doesn’t require any cross-team coordination.<br>使用这样的与团队架构一致的BFF的好处是，创建界面的团队在思考功能时会更加灵活。例如，他们可以决定将功能推到服务端，以促进未来的重用并简化本地移动端程序，或者允许更快地发布新功能（因为你可以绕过应用商店审查流程）。如果团队同时拥有移动端和BFF，则可以单独做出这一决定————这不需要任何团队协调。</p><p>General Perimeter Concerns</p><h1 id="一般周边问题"><a class="header-anchor" href="#一般周边问题">#</a>一般周边问题</h1><p>Some people use BFFs to implement generic perimeter concerns, such as authentication/authorisation or request logging. I’m torn about this. On the one hand, much of this functionality is so generic that I’d be inclined to implement it using another layer sitting further upstream, perhaps using something like a tier of Nginx or Apache servers. On the other hand, such an additional layer can’t help but add latency. BFFs are often used in microservice environment where we are already very sensitive about latency due to the high number of network calls being made. Also, the more layers you have to deploy to make a production-like stack can make development and test more complex - having all of these concerns inside the BFF as a more self-contained solution can be attractive as a result:<br>一些人使用BFF来解决一般的外围问题，例如身份验证/授权或请求日志记录。我为此感到难过。一方面，这种功能的大部分是通用的，所以我倾向于使用更上游的一层来实现它，可能使用Nginx或者Apache之类的东西。另一方面，这样的附加层会增加延迟。BFF通常用于微服务环境，在微服务环境中，由于进行了大量的网络调用，我们对延迟非常敏感。此外，为了制作类似生产的堆栈，你必须部署的层越多，开发和测试就越复杂。因此，将所有这些问题作为一个更独立的解决方案放在BFF中可能会更有吸引力：<br><img src="perimeter-layer.jpg" alt="" title="使用网络应用实现一般的外围问题"></p><figcaption>使用网络应用实现一般的外围问题</figcaption><p>As we discussed earlier, another way to factor out this duplication could be to use a shared library. Assuming your BFFs are using the same technology, this shouldn’t be too difficult, although the usual caveats about shared libraries in a microservice architecture apply.<br>正如我们之前讨论的，消除这种冗余的另一种方案就是使用共享库。假设你的BFF使用相同的技术，这应该不会太困哪，尽管微服务架构中共享库的常见警告仍然适用。</p><p>When To Use</p><h1 id="何时应用"><a class="header-anchor" href="#何时应用">#</a>何时应用</h1><p>For an application which is only providing a web UI, I suspect a BFF will only make sense if and when you have a significant amount of aggregation required on the server-side. Otherwise, I think other UI composition techniques can work just as well without requiring an additional server-side component (I’ll hopefully talk about those soon).<br>对于只提供web UI的应用程序，我怀疑只有在服务端需要大量聚合时，BFF才有意义。否则，我认为其他UI组合技术也可以正常工作，而不需要额外的服务端组件（我希望很快就会讨论这些）。</p><p>The moment that you need to provide specific functionality for a mobile UI or third party though, I would strongly consider using a BFFs for each party from the outset. I might reconsider if the cost of deploying additional services is high, but the separation of concerns that a BFF can bring make it a fairly compelling proposition in most cases. I’d be even more inclined to use a BFF if there is a significant separation between the people building the UI and downstream services, for reasons outlined above.<br>当你需要为移动端或第三方提供特定功能时，我会强烈考虑从一开始就为每一方构建一个BFF。如果部署额外服务的成本很高，我可能会重新考虑，但BFF可能带来的消解耦合使它在大多数情况下是一个相当有说服力的建议。如果构建UI的人员和下游服务之间存在明显的分离，处于上述原因，我更倾向于使用BFF。</p><p>Further Reading (And Viewing)</p><h1 id="延伸阅读-或访谈"><a class="header-anchor" href="#延伸阅读-或访谈">#</a>延伸阅读（或访谈）</h1><ul><li><p>Since I wrote this piece, Lukasz Plotnicki from ThoughtWorks has published a great article on SoundCloud’s use of the BFF pattern</p></li><li><p>Lukasz being interviewed about the pattern (and other things) on a recent episode of the Software Engineering Podcast.</p></li><li><p>Bora Tunca from SoundCloud also goes into more detail during a talk at microxchg 2016.</p></li><li><p>在我写了这篇文章之后，Lukasz Plotnicki在ThoughtWorks发了<a href="https://www.thoughtworks.com/insights/blog/bff-soundcloud">一篇文章</a>，讲述了在SoundCloud如何使用BFF模式</p></li><li><p>Lukasz在最近一集的Software Engineering Podcast中接受了关于模式（和其他事情）的<a href="http://softwareengineeringdaily.com/2016/02/04/moving-to-microservices-at-soundcloud-with-lukasz-plotnicki/">采访</a>。</p></li><li><p>SoundCloud的Bora Tunca也在<a href="https://www.youtube.com/watch?v=jfN6HOgURXM">一次访谈</a>中讲述了一些细节</p></li></ul><p>Conclusion</p><h1 id="结论"><a class="header-anchor" href="#结论">#</a>结论</h1><p>Backends For Frontends solve a pressing concern for mobile development when using microservices. In addition they provide a compelling alternative to the general-purpose API backend, and many teams make use of them for purposes other than just mobile development. The simple act of limiting the number of consumers they support makes them much easier to work with and change, and helps teams developing customer-facing applications retain more autonomy.<br>Backends For Frontends解决了使用微服务时移动端开发的一个紧迫问题。此外，它们为通用API后端提供了一个引人注目的替代方案，许多团队将其用于移动端开发之外的其他目的。简单地限制客户端支持的用户数量使他们更容易处理和更改，并帮助开发面向客户的应用程序的团队在开发面向客户的应用程序时保留更多的自主权。</p><p>Thanks go to Matthias Käppler, Michael England, Phil Calçado, Lukasz Plotnicki, Jon Eaves, Stewart Gleadow and Kristof Adriaenssens for their help in researching this article, and Giles Alexander, Ken McCormack, Sriram Viswanathan, Kornelis Sietsma, Hany Elemary, Martin Fowler, Vladimir Sneblic, and Pete Hodgson for general feedback. I’d really appreciate any further feedback too, so feel free to leave a comment below!<br>感谢Matthias Käppler、Michael England、Phil Calçado、Lukasz Plotnicki、Jon Eaves、Stewart Gleadow和Kristof Adriaenssens在研究本文时提供的帮助，感谢Giles Alexander、Ken McCormack、Sriram Viswanathan、Kornelis Sietsma、Hany Elemary、Martin Fowler、Vladimir Sneblic和Pete Hodgson提供的一般反馈。我也非常感谢任何进一步的反馈，所以欢迎在下面留言！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pattern: Backends For Frontends&lt;/p&gt;
&lt;h1 id=&quot;模式：backends-for-frontends&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#模式：backends-for-frontends&quot;&gt;#&lt;/a&gt;模式</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="BFF" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/BFF/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="BFF" scheme="http://localhost:5000/tags/BFF/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题修改1</title>
    <link href="http://localhost:5000/2022/11/23/hexo_theme_1/"/>
    <id>http://localhost:5000/2022/11/23/hexo_theme_1/</id>
    <published>2022-11-23T05:29:45.000Z</published>
    <updated>2022-11-23T13:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo基本简介"><a class="header-anchor" href="#hexo基本简介">#</a>hexo基本简介</h1><p>至于hexo的到处都是的东西我就不说了。<br>首先有render，hexo可以换render的。上网一搜就能找到，基本是<code>hexo-render</code>开头的npm包。<br>然后也有一个渲染的钩子函数之类的东西，我也不是很清楚。<br>最后也有插件。在hexo的包里就能找到<code>plugin</code>文件夹。里面就是通过插件的方式加入的hexo基础功能，比如文档里介绍的变量和函数。</p><p>渲染模板有很多，比如ejs。可以去ejs的文档里找。。</p><h1 id="修改indigo"><a class="header-anchor" href="#修改indigo">#</a>修改indigo</h1><p>indigo是hexo官网里就能找到的主题。不过直接<code>git clone</code>是使用不了的。<br>总之各种问题。</p><p>首先是lodash的问题。旧版hexo会携带lodash包，并且在变量里用<code>_</code>引入。在新版hexo中，需要用插件的方式将其引入，使得indigo可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;template_locals&#x27;</span>, <span class="function"><span class="params">locals</span> =&gt;</span> &#123;</span><br><span class="line">locals.<span class="property">_</span> = lodash;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后的日期问题。hexo文档里虽说是用<code>moment</code>来格式化时间，实际上是<code>moment-timezone</code>。</p><p>在插件文件中加入，实现月份的中文化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">moment.<span class="title function_">updateLocale</span>(<span class="string">&#x27;zh-cn&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">months</span>: [</span><br><span class="line">      <span class="string">&#x27;一月&#x27;</span>, <span class="string">&#x27;二月&#x27;</span>, <span class="string">&#x27;三月&#x27;</span>, <span class="string">&#x27;四月&#x27;</span>, <span class="string">&#x27;五月&#x27;</span>, <span class="string">&#x27;六月&#x27;</span>, <span class="string">&#x27;七月&#x27;</span>, <span class="string">&#x27;八月&#x27;</span>, <span class="string">&#x27;九月&#x27;</span>, <span class="string">&#x27;十月&#x27;</span>, <span class="string">&#x27;十一月&#x27;</span>, <span class="string">&#x27;十二月&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">moment.<span class="title function_">locale</span>()</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">helper</span>.<span class="title function_">register</span>(<span class="string">&#x27;data_format&#x27;</span>, <span class="function">(<span class="params">date, format</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">moment</span>(date).<span class="title function_">format</span>(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="本人的其他修改"><a class="header-anchor" href="#本人的其他修改">#</a>本人的其他修改</h1><p>细节就不多说了。<br>比如简单的格式修改。<br>还有滚动文章页面时，原代码里劫持了事件，我给注释了。<br>就是这篇文章。。页内锚点链接需要<code>encodeURI</code>转换。</p><p>重点是<code>tag</code>和<code>category</code>。初用者一定不清楚两者之间区别。<br>实际上，<code>tag</code>译为标签，一篇文章里的标签之间是平级关系；<code>category</code>却不是。<br>可以在hexo中的<code>plugin</code>文件夹里寻找到<code>list_categories</code>函数的实现。顺便在插件文件中复制一份，并且打印一下<code>category</code>就会发现，它是有<code>parent</code>这种东西的。<br>所以我就将其作为目录一样的存在，并在插件中实现了一下，在<code>/categories</code>路径下渲染了一下。</p><h1 id="最后"><a class="header-anchor" href="#最后">#</a>最后</h1><p>最后的结果，虽然页面和原先很像，但也经过一定的美化，并且在新版的hexo变得可用了，更符合我的心意。<br>然后我上传到github上，<a href="https://github.com/el-psy/my-hexo-theme">my-hexo-theme</a><br>自己用的时候别范那种把我的邮箱放到最终页面上的低级错误。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo基本简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#hexo基本简介&quot;&gt;#&lt;/a&gt;hexo基本简介&lt;/h1&gt;
&lt;p&gt;至于hexo的到处都是的东西我就不说了。&lt;br&gt;
首先有render，hexo可以换render的。上网一搜就能找到</summary>
      
    
    
    
    <category term="hexo" scheme="http://localhost:5000/categories/hexo/"/>
    
    <category term="主题" scheme="http://localhost:5000/categories/hexo/%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="hexo主题" scheme="http://localhost:5000/tags/hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
