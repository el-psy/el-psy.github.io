<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七翼式</title>
  
  <subtitle>不对称</subtitle>
  <link href="http://localhost:5000/atom.xml" rel="self"/>
  
  <link href="http://localhost:5000/"/>
  <updated>2023-05-03T09:27:32.000Z</updated>
  <id>http://localhost:5000/</id>
  
  <author>
    <name>el_psy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bert个人总结</title>
    <link href="http://localhost:5000/2023/05/03/Bert%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://localhost:5000/2023/05/03/Bert%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</id>
    <published>2023-05-03T05:32:01.000Z</published>
    <updated>2023-05-03T09:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="header-anchor" href="#简介">#</a>简介</h1><p>bert大名不必多提。作为动态词嵌入最有名的模型，解析的博客数不胜数。什么transformer之类的本文一概不提。<br>本文简单叙述一下bert代码。<br>然后有精力的话，再用其他几篇文章总结一下bert出现之后的其他改进模型。</p><h1 id="代码总览"><a class="header-anchor" href="#代码总览">#</a>代码总览</h1><p>代码位于<a href="https://github.com/google-research/bert">bert</a></p><pre class="line-numbers language-none"><code class="language-none">Mode                 LastWriteTime         Length Name----                 -------------         ------ -----a----         2023&#x2F;4&#x2F;29     18:28           1477 .gitignore-a----         2023&#x2F;4&#x2F;29     18:28           1354 CONTRIBUTING.md-a----         2023&#x2F;4&#x2F;29     18:28          11560 LICENSE-a----         2023&#x2F;4&#x2F;29     18:28          51636 README.md-a----         2023&#x2F;4&#x2F;29     18:28            631 __init__.py-a----         2023&#x2F;4&#x2F;29     18:28          16944 create_pretraining_data.py-a----         2023&#x2F;4&#x2F;29     18:28          14317 extract_features.py-a----         2023&#x2F;4&#x2F;29     18:28          38908 modeling.py-a----         2023&#x2F;4&#x2F;29     18:28           9468 modeling_test.py-a----         2023&#x2F;4&#x2F;29     18:28          11545 multilingual.md-a----         2023&#x2F;4&#x2F;29     18:28           6432 optimization.py-a----         2023&#x2F;4&#x2F;29     18:28           1769 optimization_test.py-a----         2023&#x2F;4&#x2F;29     18:28          67718 predicting_movie_reviews_with_bert_on_tf_hub.ipynb-a----         2023&#x2F;4&#x2F;29     18:28            112 requirements.txt-a----         2023&#x2F;4&#x2F;29     18:28          35764 run_classifier.py-a----         2023&#x2F;4&#x2F;29     18:28          11740 run_classifier_with_tfhub.py-a----         2023&#x2F;4&#x2F;29     18:28          19160 run_pretraining.py-a----         2023&#x2F;4&#x2F;29     18:28          47815 run_squad.py-a----         2023&#x2F;4&#x2F;29     18:28           4427 sample_text.txt-a----         2023&#x2F;4&#x2F;29     18:28          12656 tokenization.py-a----         2023&#x2F;4&#x2F;29     18:28           4726 tokenization_test.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>create_pretraining_data.py</code>用于处理数据，<code>modeling.py</code>是模型及其配置对象所在，<code>run_pretraining.py</code>是bert模型训练所用。</p><h1 id="数据处理"><a class="header-anchor" href="#数据处理">#</a>数据处理</h1><h2 id="启动"><a class="header-anchor" href="#启动">#</a>启动</h2><p>代码的<code>README.md</code>叙述了代码处理命令。<br>其中使用了<code>tensorflow</code>的flags处理了命令行指令的参数。<br>使用<code>tf.app.run()</code>启动了<code>main</code>函数。</p><h2 id="main函数"><a class="header-anchor" href="#main函数">#</a>main函数</h2><ol><li>使用tf.logging设置了日志级别</li><li>创建tokenizer。熟悉huggingface的人应该不陌生。</li><li>读取命令行指令参数中的输入文件名，放到<code>input_files</code>数组里。并在日志输出</li><li>使用<code>create_training_instances</code>函数创建<code>instances</code>数组</li><li>使用<code>write_instance_to_example_files</code>函数将<code>instances</code>数组存放到指令中的输入文件参数里。</li></ol><h2 id="create-training-instances函数"><a class="header-anchor" href="#create-training-instances函数">#</a>create_training_instances函数</h2><ol><li>随机打乱document</li><li>控制每条数据长度。以0.5的概率随机插入，如果是随机<code>is_random_next</code>值为True，否则为False</li><li>token中使用<code>[CLS]</code>和<code>[SEP]</code>分隔符</li><li>使用<code>TrainingInstance</code>创建<code>instance</code>并保存在<code>instances</code>数组里。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">instance <span class="token operator">=</span> TrainingInstance<span class="token punctuation">(</span>    tokens<span class="token operator">=</span>tokens<span class="token punctuation">,</span> <span class="token comment"># token分词结果列表，其中已经包含mask了</span>    segment_ids<span class="token operator">=</span>segment_ids<span class="token punctuation">,</span> <span class="token comment"># 对应token的列表，由0， 1组成，代表前后两个分句</span>    is_random_next<span class="token operator">=</span>is_random_next<span class="token punctuation">,</span> <span class="token comment"># 与segment_ids对应。如果两个分句在原文中是连续的为False；如果是随机链接（概率0.5）的话为True</span>    masked_lm_positions<span class="token operator">=</span>masked_lm_positions<span class="token punctuation">,</span> <span class="token comment"># mask词对应的index</span>    masked_lm_labels<span class="token operator">=</span>masked_lm_labels<span class="token punctuation">)</span> <span class="token comment"># 与之对应的mask词的token</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="write-instance-to-example-files函数"><a class="header-anchor" href="#write-instance-to-example-files函数">#</a>write_instance_to_example_files函数</h2><p>主要就是将下面这些写入文件中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">features <span class="token operator">=</span> collections<span class="token punctuation">.</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_int_feature<span class="token punctuation">(</span>input_ids<span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"input_mask"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_int_feature<span class="token punctuation">(</span>input_mask<span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"segment_ids"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_int_feature<span class="token punctuation">(</span>segment_ids<span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"masked_lm_positions"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_int_feature<span class="token punctuation">(</span>masked_lm_positions<span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"masked_lm_ids"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_int_feature<span class="token punctuation">(</span>masked_lm_ids<span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"masked_lm_weights"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_float_feature<span class="token punctuation">(</span>masked_lm_weights<span class="token punctuation">)</span>features<span class="token punctuation">[</span><span class="token string">"next_sentence_labels"</span><span class="token punctuation">]</span> <span class="token operator">=</span> create_int_feature<span class="token punctuation">(</span><span class="token punctuation">[</span>next_sentence_label<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 上面的is_random_next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="预训练"><a class="header-anchor" href="#预训练">#</a>预训练</h1><h2 id="总览"><a class="header-anchor" href="#总览">#</a>总览</h2><p>代码的<code>README.md</code>叙述了代码处理命令。<br>其中使用了<code>tensorflow</code>的flags处理了命令行指令的参数。<br>使用<code>tf.app.run()</code>启动了<code>main</code>函数。</p><h2 id="main函数"><a class="header-anchor" href="#main函数">#</a>main函数</h2><ol><li>修改tf的logging等级</li><li>检验命令行参数中的train和eval，要么是评估模型，要么是训练模型</li><li>生成bert的config</li><li>读取输入文件名</li><li>tpu相关，不明</li><li>以<code>model_fn_builder</code>函数生成<code>model_fn</code></li><li>训练或者评估，然后日志</li></ol><h2 id="model-fn-builder函数"><a class="header-anchor" href="#model-fn-builder函数">#</a>model_fn_builder函数</h2><ol><li>读取输入数据</li><li>使用模型</li><li>计算loss</li></ol><p>从loss入手</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span>masked_lm_loss<span class="token punctuation">,</span> masked_lm_example_loss<span class="token punctuation">,</span> masked_lm_log_probs<span class="token punctuation">)</span> <span class="token operator">=</span> get_masked_lm_output<span class="token punctuation">(</span>     bert_config<span class="token punctuation">,</span> model<span class="token punctuation">.</span>get_sequence_output<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>get_embedding_table<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     masked_lm_positions<span class="token punctuation">,</span> masked_lm_ids<span class="token punctuation">,</span> masked_lm_weights<span class="token punctuation">)</span><span class="token punctuation">(</span>next_sentence_loss<span class="token punctuation">,</span> next_sentence_example_loss<span class="token punctuation">,</span> next_sentence_log_probs<span class="token punctuation">)</span> <span class="token operator">=</span> get_next_sentence_output<span class="token punctuation">(</span>     bert_config<span class="token punctuation">,</span> model<span class="token punctuation">.</span>get_pooled_output<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> next_sentence_labels<span class="token punctuation">)</span>total_loss <span class="token operator">=</span> masked_lm_loss <span class="token operator">+</span> next_sentence_loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明显看出来bert预训练的两大任务，mask词预测和下一句预测。<br>从<code>modeling.py</code>中分析可知，</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">model<span class="token punctuation">.</span>get_sequence_output<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 获取bert中的encoder输出，也就是transformer的输出</span>model<span class="token punctuation">.</span>get_embedding_table<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 获取bert第一步的输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里简单提一下bert的模型。<br>第一步是根据词的id（一个int）在embdding层找到对应的向量，多个词组成一句话形成一个矩阵。<br>第二步是将这个矩阵输入到一组transformer模型中，得到bert输出的词向量<br>第三步时其他层，稍后再讲。</p><p>这里mask词预测任务用到了bert输出的词向量，和embedding层输出，没记错两者长度都是<code>bert_config.hidden_size</code><br>具体上，先将词向量进行线性变换，然后与embedding层输出相乘，然后进行<code>log_softmax</code>，与mask位置进行比较（mask的one_hot），得到loss。</p><p>前后句预测任务。<br>输入时的<code>segment_id</code>（前句为0，后句为1）分割了前后句。<br>首先<code>modeling.py</code>第三步有一个<code>pooler</code>，将词向量输出的第一个词的向量进行线性变换并输出，得到<code>pooled_output</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> tf<span class="token punctuation">.</span>variable_scope<span class="token punctuation">(</span><span class="token string">"pooler"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># We "pool" the model by simply taking the hidden state corresponding</span>    <span class="token comment"># to the first token. We assume that this has been pre-trained</span>    first_token_tensor <span class="token operator">=</span> tf<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>self<span class="token punctuation">.</span>sequence_output<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>pooled_output <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>dense<span class="token punctuation">(</span>        first_token_tensor<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span>        activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>tanh<span class="token punctuation">,</span>        kernel_initializer<span class="token operator">=</span>create_initializer<span class="token punctuation">(</span>config<span class="token punctuation">.</span>initializer_range<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算loss时将其进行线性变换为长度为2的向量。<br>需要预测的值是数据预处理是的<code>is_random_next</code>。<br>交叉熵loss。</p><h1 id="最后"><a class="header-anchor" href="#最后">#</a>最后</h1><p>想必这篇文章与之前读过的bert博客不同。<br>这也是我的初衷。<br>要写点别人没有的。<br>想必读完这篇之后会对bert源码有初步的了解。<br>对于bert模型如何训练会有更深的了解。<br>知道两大任务到底如何实现的。<br>之后我还会随便总结一下其他bert改进模型，不过那就是没什么营养人云亦云了。<br>反正我也不想在此领域深究。<br>饶过我的2GB显存的小笔记本吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;#&lt;/a&gt;简介&lt;/h1&gt;
&lt;p&gt;bert大名不必多提。作为动态词嵌入最有名的模型，解析的博客数不胜数。什么transformer之类的本文一概不提。&lt;br&gt;
本文简单叙述一下bert代</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://localhost:5000/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="NLP" scheme="http://localhost:5000/tags/NLP/"/>
    
    <category term="bert" scheme="http://localhost:5000/tags/bert/"/>
    
  </entry>
  
  <entry>
    <title>graphql-introspection</title>
    <link href="http://localhost:5000/2023/01/11/graphql-introspection/"/>
    <id>http://localhost:5000/2023/01/11/graphql-introspection/</id>
    <published>2023-01-11T06:55:18.000Z</published>
    <updated>2023-01-11T07:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://graphql.org/learn/introspection/">Introspection</a>翻译</p></blockquote><p>向GraphQL模式询问有关其支持的查询的信息通常非常有用。GraphQL允许我们使用introspection系统这样做。</p><p>对于我们的《星球大战》示例，文件<a href="https://github.com/graphql/graphql-js/blob/main/src/__tests__/starWarsIntrospection-test.ts">starWarsIntrossection-test.ts</a>包含很多演示introspection系统的查询，并且是一个测试用例文件，可以运行该文件来练习参考实现的introspection系统。</p><p>我们设计了类型系统，所以我们知道哪些类型是可用的。但如果我们不知道，则可以通过查询<code>__schema</code>字段来询问GraphQL，该字段在查询的根类型上总是可用的。现在让我们这么做，并询问可用的类型。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">__schema</span> <span class="token punctuation">&#123;</span>    <span class="token object">types</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__schema"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"types"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Query"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ID"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Mutation"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Episode"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Character"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Int"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LengthUnit"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Human"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Float"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Droid"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"FriendsConnection"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"FriendsEdge"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"PageInfo"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Boolean"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Review"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ReviewInput"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Starship"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"SearchResult"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__Schema"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__Type"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__TypeKind"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__Field"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__InputValue"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__EnumValue"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__Directive"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"__DirectiveLocation"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哦，有个类型海。它们都是什么水？让我们将它们分组：</p><ul><li><p><code>Query, Character, Human, Episode, Droid</code>——这些是我们在类型系统中定义的。</p></li><li><p><code>String, Boolean</code>——这些事类型系统提供的内建标量。</p></li><li><p><code>__Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive</code>——这些都以双下划线开头，表示它们是内建系统的一部分。</p></li></ul><p>现在，让我们试着找出一个好方法，开始探索可用的查询。当我们设计类型系统时，我们指定了多有查询的起始类型；让我们问问内省系统吧！</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">__schema</span> <span class="token punctuation">&#123;</span>    <span class="token object">queryType</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__schema"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"queryType"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Query"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这与我们在类型系统中说的一致，查询类型是我们将开始的地方。注意这里的命名只是按照管理；我们可以将我们的查询类型命名为任何其他类型，如果我们将其指定为查询的起始类型，它仍然会返回到这里。不过，将其命名为<code>Query</code>是一个有用的约定。</p><p>检查一个特定的类型通常很有用。让我们看看<code>Droid</code>类型。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">__type</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Droid"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Droid"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过，如果我们想了解更多<code>Droid</code>的信息呢？例如，它是接口还是对象？</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">__type</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Droid"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">kind</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Droid"</span><span class="token punctuation">,</span>      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"OBJECT"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>kind</code>返回一个<code>__TypeKind</code>枚举类型，其中一个值是<code>OBJECT</code>.如果我们询问<code>Character</code>，我们会发现它是一个接口：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">__type</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Character"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">kind</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Character"</span><span class="token punctuation">,</span>      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"INTERFACE"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一个对象知道它有什么字段是很有用的，所以让我们问问<code>Droid</code>的introspection系统：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">__type</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Droid"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token object">fields</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>      <span class="token keyword">type</span> <span class="token punctuation">&#123;</span>        <span class="token property">name</span>        <span class="token property">kind</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Droid"</span><span class="token punctuation">,</span>      <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"id"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"name"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"friends"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"LIST"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"friendsConnection"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"appearsIn"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"primaryFunction"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些就是我们在<code>Droid</code>上定义的字段。</p><p><code>id</code>看起来有点奇怪，它没有类型的名称。这是因为它是<code>NON_NULL</code>类型的包装类型。如果我们在该字段的类型上查询<code>type</code>，我们将在哪里找到<code>ID</code>类型，并告诉我们这是一个非空<code>ID</code>。</p><p>同样，<code>friends</code>和<code>appearsln</code>上都没有<code>name</code>，因为它们是<code>LIST</code>包装类型。我们可以在这里类型上查询<code>type</code>，这将告诉我们这些是什么列表。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">__type</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Droid"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token object">fields</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>      <span class="token keyword">type</span> <span class="token punctuation">&#123;</span>        <span class="token property">name</span>        <span class="token property">kind</span>        <span class="token object">ofType</span> <span class="token punctuation">&#123;</span>          <span class="token property">name</span>          <span class="token property">kind</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Droid"</span><span class="token punctuation">,</span>      <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"id"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ID"</span><span class="token punctuation">,</span>              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"name"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"friends"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"LIST"</span><span class="token punctuation">,</span>            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Character"</span><span class="token punctuation">,</span>              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"INTERFACE"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"friendsConnection"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"FriendsConnection"</span><span class="token punctuation">,</span>              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"OBJECT"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"appearsIn"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"LIST"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"primaryFunction"</span><span class="token punctuation">,</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span><span class="token punctuation">,</span>            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token null keyword">null</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们对特别有用的introspection的一个特性作为结尾；让我们向系统索取文档！</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">__type</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"Droid"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">description</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Droid"</span><span class="token punctuation">,</span>      <span class="token property">"description"</span><span class="token operator">:</span> <span class="token null keyword">null</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，我们可以使用introspection系统来访问有关类型系统的文档，并创建文档浏览器，或丰富的IDE体验。</p><p>这只是触及了introspection系统的表面，我们可以查询枚举值、类型实现的接口等。我们甚至可以introspection  introspection系统本身。规范在<a href="https://github.com/graphql/graphql-js/blob/main/src/type/introspection.ts">introspection</a>一节中详细介绍，GraphQL.js中的introspection文件包含实现符合规范的GraphQL查询introspection系统的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://graphql.org/learn/introspection/&quot;&gt;Introspection&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;向GraphQL模式询问有关其支持的查询的信息通常非常有用。Gr</summary>
      
    
    
    
    <category term="graphql" scheme="http://localhost:5000/categories/graphql/"/>
    
    <category term="introspection" scheme="http://localhost:5000/categories/graphql/introspection/"/>
    
    
    <category term="graphql" scheme="http://localhost:5000/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>graphql-execution</title>
    <link href="http://localhost:5000/2023/01/11/graphql-execution/"/>
    <id>http://localhost:5000/2023/01/11/graphql-execution/</id>
    <published>2023-01-11T04:49:52.000Z</published>
    <updated>2023-01-11T06:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://graphql.org/learn/execution/">Execution</a>翻译</p></blockquote><p>经过验证后，GraphQL查询由GraphQL服务器执行，该服务器返回一个反映所请求查询形状的结果，通常为JSON。</p><p>GraphQL无法在没有类型系统的情况下执行查询，让我们使用一个示例类型系统来说明执行查询。这是本文示例中使用的同一类型系统的一部分：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">human</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Human</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span>  <span class="token attr-name">appearsIn</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Episode</span><span class="token punctuation">]</span>  <span class="token attr-name">starships</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Starship</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token class-name">Episode</span> <span class="token punctuation">&#123;</span>  <span class="token constant">NEWHOPE</span>  <span class="token constant">EMPIRE</span>  <span class="token constant">JEDI</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Starship</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了描述执行查询时发生的情况，让我们使用一个示例来了解一下。</p><p>你可以将GraphQL查询中的每个字段视为返回下一个类型的前一个类型的函数或方法。事实上，这正是GraphQL的工作原理。每种类型上的每个字段都由GraphQL服务器开发人员提供的名为解析器的函数支持。每当执行一个字段时，将调用相应的解析器来说生成下一个值。</p><p>如果一个字段产生一个标量值，如字符串或数字，则执行完成。但是，如果字段产生对象值，则查询将包含应用该对象的另一个字段选择。浙江一直持续达到标量值。GraphQL查询始终以标量值结尾。</p><h1 id="root-fields-resolvers-跟字段和解析器"><a class="header-anchor" href="#root-fields-resolvers-跟字段和解析器">#</a>Root fields &amp; resolvers 跟字段和解析器</h1><p>在每个GraphQL服务器的顶层都有一种类型，它表示GraphQL API的所有可能入口，通常成为根类型或查询类型。</p><p>在本例中，我们的查询类型提供了一个名为<code>human</code>的字段，该字段接收参数id。该字段的解析器函数可能访问数据库，然后构造并返回一个<code>human</code>对象。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token attr-name">Query</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">human</span><span class="token punctuation">(</span><span class="token property">obj</span><span class="token punctuation">,</span> <span class="token property">args</span><span class="token punctuation">,</span> <span class="token property">context</span><span class="token punctuation">,</span> <span class="token property">info</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">return</span> <span class="token property">context</span>.<span class="token property">db</span>.<span class="token property-query">loadHumanByID</span><span class="token punctuation">(</span><span class="token property">args</span>.<span class="token property">id</span><span class="token punctuation">)</span>.<span class="token property-query">then</span><span class="token punctuation">(</span>      <span class="token property">userData</span> <span class="token operator">=</span>> <span class="token property">new</span> <span class="token property-query">Human</span><span class="token punctuation">(</span><span class="token property">userData</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子是用JavaScript编写的，但是GraphQL服务器可以用<a href="https://graphql.org/code/">许多不同的语言</a>构建。解析器函数接收四个参数：</p><ul><li><p>obj 前一对象，在根查询类型上该字段通常不使用。</p></li><li><p>args 为GraphQL查询中的字段提供参数。</p></li><li><p>context 提供给每个解析器的一个值，它保存重要的上下文信息，如当前登录的用户或对数据库的访问。</p></li><li><p>info 保存与当前查询相关的字段特定信息以及模式详细信息的值，详细信息可以查阅<a href="https://graphql.org/graphql-js/type/#graphqlobjecttype">Graphql解析器info类型的更多细节</a>。</p></li></ul><h1 id="asynchronous-resolvers-异步解析器"><a class="header-anchor" href="#asynchronous-resolvers-异步解析器">#</a>Asynchronous resolvers 异步解析器</h1><p>让我们仔细看看这个解析器函数中发生了什么。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token property-query">human</span><span class="token punctuation">(</span><span class="token property">obj</span><span class="token punctuation">,</span> <span class="token property">args</span><span class="token punctuation">,</span> <span class="token property">context</span><span class="token punctuation">,</span> <span class="token property">info</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property">return</span> <span class="token property">context</span>.<span class="token property">db</span>.<span class="token property-query">loadHumanByID</span><span class="token punctuation">(</span><span class="token property">args</span>.<span class="token property">id</span><span class="token punctuation">)</span>.<span class="token property-query">then</span><span class="token punctuation">(</span>    <span class="token property">userData</span> <span class="token operator">=</span>> <span class="token property">new</span> <span class="token property-query">Human</span><span class="token punctuation">(</span><span class="token property">userData</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>context</code>用于提供对数据库的访问，该数据库用于通过在GraphQL查询中作为参数提供的id为用户加载数据。由于从数据库加载是一个异步操作，因此返回Promise。在JavaScript中，Promise用于处理异步值，但在许多语言中都存在相同的概念，通常称为<code>Futures</code>、<code>Task</code>或<code>Deferred</code>。当数据库返回时，我们可以构造并返回一个新的<code>Human</code>对象。</p><p>请注意，虽然解析器函数需要知道Promise，但GraphQL查询不需要。它只希望human字段返回一些东西，然后可以查询器name。在执行过程中，GraphQL将等待<code>Promise</code>、<code>Futures</code>和<code>Tasks</code>完成，然后继续执行，并以最佳并发性执行。</p><h1 id="trivial-resolvers-简单解析器"><a class="header-anchor" href="#trivial-resolvers-简单解析器">#</a>Trivial resolvers 简单解析器</h1><p>既然<code>Human</code>对象可用，GraphQL执行可以继续执行其上请求的字段。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token attr-name">Human</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">name</span><span class="token punctuation">(</span><span class="token property">obj</span><span class="token punctuation">,</span> <span class="token property">args</span><span class="token punctuation">,</span> <span class="token property">context</span><span class="token punctuation">,</span> <span class="token property">info</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">return</span> <span class="token property">obj</span>.<span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Graphql服务器根据类型系统知道下一步需要做什么。即在<code>Human</code>字段返回任何内容之前，GraphQL知道下一步将是解析<code>Human</code>类型上的字段，因为类型系统告诉它<code>human</code>字段将返回一个<code>Human</code>。</p><p>在这种情况下解析<code>name</code>非常简单。调用<code>name</code>解析器函数，obj参数是从上一个字段返回的新<code>Human</code>对象。在这种情况下，我们希望<code>Human</code>对象具有一个<code>name</code>属性，我们可以直接读取并返回该属性。</p><p>事实上，许多GraphQL库将允许你省略这么简单的解析器，并假设如果没有为字段提供解析器，则将读取并返回同名属性。</p><h1 id="scalar-coercion-标量强制"><a class="header-anchor" href="#scalar-coercion-标量强制">#</a>Scalar coercion 标量强制</h1><p>解析<code>name</code>字段时，可以同时解析<code>appearsln</code>和<code>starships</code>字段。<code>appearsln</code>字段也可能有一个简单的解析器，但让我们仔细看看：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token attr-name">Human</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">appearsIn</span><span class="token punctuation">(</span><span class="token property">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">return</span> <span class="token property">obj</span>.<span class="token property">appearsIn</span> // <span class="token property">returns</span> <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，我们的类型系统表明<code>appearsln</code>将返回具有已知值的枚举类型，但此函数返回的是数字！事实上，如果我们查看结果，就会看到返回了正确的枚举值。发生了什么事？</p><p>这就是标量强制的一个例子。类型系统知道需要什么，并将解析器函数返回的值转换为支持API约定的值。在这种情况下，我们的服务器上可能定义了一个枚举类型，它在内部使用4、5、6等数字，但在GraphQL类型系统中它们将表示为枚举值。</p><h1 id="list-resolvers-列表解析器"><a class="header-anchor" href="#list-resolvers-列表解析器">#</a>List resolvers 列表解析器</h1><p>我们已经看到了当一个字段返回一个上面的<code>appearsln</code>字段的列表时会发生什么。它返回了一个枚举值列表，因为这是类型系统所期望的，所以列表中的每个值都被强制转换为对应的枚举值。而当<code>starship</code>字段解析时会发生什么？</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token attr-name">Human</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">starships</span><span class="token punctuation">(</span><span class="token property">obj</span><span class="token punctuation">,</span> <span class="token property">args</span><span class="token punctuation">,</span> <span class="token property">context</span><span class="token punctuation">,</span> <span class="token property">info</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">return</span> <span class="token property">obj</span>.<span class="token property">starshipIDs</span>.<span class="token property-query">map</span><span class="token punctuation">(</span>      <span class="token property">id</span> <span class="token operator">=</span>> <span class="token property">context</span>.<span class="token property">db</span>.<span class="token property-query">loadStarshipByID</span><span class="token punctuation">(</span><span class="token property">id</span><span class="token punctuation">)</span>.<span class="token property-query">then</span><span class="token punctuation">(</span>        <span class="token property">shipData</span> <span class="token operator">=</span>> <span class="token property">new</span> <span class="token property-query">Starship</span><span class="token punctuation">(</span><span class="token property">shipData</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此字段的解析器不仅返回一个Promise，还返回了Promise列表。<code>Human</code>对象有它们驾驶的星际飞船的id列表，但我们需要加载所有这些id才能获得真正的<code>Starship</code>对象。</p><p>GraphQL在下一步之前会等待所有这些Promise完成，留下一个对象列表，并将再次同时加载每个项的<code>name</code>字段。</p><h1 id="producing-the-result-生成结果"><a class="header-anchor" href="#producing-the-result-生成结果">#</a>Producing the result 生成结果</h1><p>当每个字段都解析完成，生成的值将被存放到一个键值映射中，字段名（或别名）作为键，解析的值作为值。这从查询的底部的叶节点一直延伸到根查询的原始字段。它们共同生成一个结构，反映了原始查询，然后可以将生成的结构（通常是JSON）发送到请求它的客户端。</p><p>让我们最后看一看原始查询，看看所有这些解析函数是如何产生结果的：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">human</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token number">1002</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">appearsIn</span>    <span class="token object">starships</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"human"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span><span class="token punctuation">,</span>      <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>        <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>        <span class="token string">"JEDI"</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"starships"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Millenium Falcon"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Imperial shuttle"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://graphql.org/learn/execution/&quot;&gt;Execution&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过验证后，GraphQL查询由GraphQL服务器执行，该服务器返回一个反映所</summary>
      
    
    
    
    <category term="graphql" scheme="http://localhost:5000/categories/graphql/"/>
    
    <category term="execution" scheme="http://localhost:5000/categories/graphql/execution/"/>
    
    
    <category term="graphql" scheme="http://localhost:5000/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>graphql-validatoin</title>
    <link href="http://localhost:5000/2023/01/11/graphql-validatoin/"/>
    <id>http://localhost:5000/2023/01/11/graphql-validatoin/</id>
    <published>2023-01-11T02:55:11.000Z</published>
    <updated>2023-01-11T03:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://graphql.org/learn/validation/">Validation</a>翻译</p></blockquote><p>通过使用类型系统，可以预先确定GraphQL查询是否有效。这允许服务器和客户端在创建无效查询时有效地通知开发人员，而无须依赖运行时检查。</p><p>对于我们的《星球大战》示例，文件<a href="https://github.com/graphql/graphql-js/blob/main/src/__tests__/starWarsValidation-test.ts">starWarsValidation-test.ts</a>包含许多无效性的查询，并且是一个测试文件，可以用来测试参考示例的验证器。</p><p>首先，让我们进行一个复杂的有效查询。这是一个嵌套查询，类似于上一节中的示例，但将重复字段分解为一个片段：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">NameAndAppearances</span>    <span class="token object">friends</span> <span class="token punctuation">&#123;</span>      <span class="token operator">...</span><span class="token fragment function">NameAndAppearances</span>      <span class="token object">friends</span> <span class="token punctuation">&#123;</span>        <span class="token operator">...</span><span class="token fragment function">NameAndAppearances</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fragment</span> <span class="token fragment function">NameAndAppearances</span> <span class="token keyword">on</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token property">name</span>  <span class="token property">appearsIn</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>        <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>        <span class="token string">"JEDI"</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>          <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>            <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>            <span class="token string">"JEDI"</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C-3PO"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span><span class="token punctuation">,</span>          <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>            <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>            <span class="token string">"JEDI"</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span><span class="token punctuation">,</span>          <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>            <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>            <span class="token string">"JEDI"</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C-3PO"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>              <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>                <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>                <span class="token string">"JEDI"</span>              <span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个查询是通过验证有效的。让我们再看一些无效的查询。</p><p>片段不能引用自身或创建循环，因为这可能会导致无边界的结果！下面和上面还是相同的查询，但没有明确三个嵌套级别：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">NameAndAppearancesAndFriends</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fragment</span> <span class="token fragment function">NameAndAppearancesAndFriends</span> <span class="token keyword">on</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token property">name</span>  <span class="token property">appearsIn</span>  <span class="token object">friends</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">NameAndAppearancesAndFriends</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Cannot spread fragment \"NameAndAppearancesAndFriends\" within itself."</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">5</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们查询字段时，我们必须查询给定类型上存在的字段。所以但<code>hero</code>返回一个<code>Character</code>时，我们必须查询<code>Character</code>上的字段。该类型没有<code>favoriteSpaceship</code>字段，因此无法查询。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token comment"># INVALID: favoriteSpaceship does not exist on Character</span><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">favoriteSpaceship</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Cannot query field \"favoriteSpaceship\" on type \"Character\"."</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">5</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每当我们查询字段时，它返回的不是标量或枚举，我们就需要指定要从字段中获取的数据。<code>hero</code>返回一个<code>Character</code>，我们一直在请求<code>name</code>和<code>appearsln</code>字段；如果忽略此项，则查询无效：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token comment"># INVALID: hero is not a scalar, so fields are needed</span><span class="token punctuation">&#123;</span>  <span class="token property">hero</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Field \"hero\" of type \"Character\" must have a selection of subfields. Did you mean \"hero &#123; ... &#125;\"?"</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">3</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似地，如果字段是标量，则在其上查询其他字段没有意义，这样做会导致查询无效：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token comment"># INVALID: name is a scalar, so fields are not permitted</span><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token object">name</span> <span class="token punctuation">&#123;</span>      <span class="token property">firstCharacterOfName</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Field \"name\" must not have a selection since type \"String!\" has no subfields."</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">10</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>早些时候，注意到查询只能查询类型上的字段；当我们查询<code>Character</code>类型的<code>hero</code>时，我们只能查询<code>Character</code>上的字段。但，我们如果想查询<code>R2-D2s</code>的<code>primaryFunction</code>时，会发生什么？</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token comment"># INVALID: primaryFunction does not exist on Character</span><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">primaryFunction</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Cannot query field \"primaryFunction\" on type \"Character\". Did you mean to use an inline fragment on \"Droid\"?"</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">5</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该查询无效，因为<code>primaryFunction</code>不是<code>Character</code>上的字段。如果<code>Character</code>是<code>Droid</code>，我们需要某种方式来表示我们希望获取<code>primaryFunction</code>，否则忽略该字段。我们可以使用前面介绍的片段来实现这一点。通过设置<code>Droid</code>上定义的片段并将其包含在内，我们确保只查询定义了它的<code>primaryFunction</code>。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token operator">...</span><span class="token fragment function">DroidFields</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fragment</span> <span class="token fragment function">DroidFields</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>  <span class="token property">primaryFunction</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"primaryFunction"</span><span class="token operator">:</span> <span class="token string">"Astromech"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个查询是有效的，但有点冗长；当我们多次使用命名片段时，上面的命名片段很好用，但我们只用了一次。我们可以使用内联片段，而不是命名片段；这仍然允许我们指明正在查询的类型，但不需要单独的命名片段：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>      <span class="token property">primaryFunction</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"primaryFunction"</span><span class="token operator">:</span> <span class="token string">"Astromech"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这仅仅触及了验证系统的表面；有许多验证规则可以确保GraphQL查询在语义上有意义。规范在<a href="https://github.com/graphql/graphql-js/blob/main/src/validation">validation</a>一节中详细介绍，GraphQL.js中的验证目录包含实现符合规范的GraphQL验证器的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://graphql.org/learn/validation/&quot;&gt;Validation&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过使用类型系统，可以预先确定GraphQL查询是否有效。这允许服务器和客户</summary>
      
    
    
    
    <category term="graphql" scheme="http://localhost:5000/categories/graphql/"/>
    
    <category term="validation" scheme="http://localhost:5000/categories/graphql/validation/"/>
    
    
    <category term="graphql" scheme="http://localhost:5000/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>graphql-schemas-types</title>
    <link href="http://localhost:5000/2023/01/09/graphql-schemas-types/"/>
    <id>http://localhost:5000/2023/01/09/graphql-schemas-types/</id>
    <published>2023-01-09T05:03:38.000Z</published>
    <updated>2023-01-10T18:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://graphql.org/learn/schema/#union-types">Schemas and Types</a>翻译</p></blockquote><p>在这篇文章中，你将了解有关GraphQL类型系统有关的所有必要知识，以及它如何描述可查询的数据。由于GraphQL可以与任何后端框架或编程语言一起使用，因此我们将忽略具体实现细节，只讨论概念。</p><h1 id="type-system-类型系统"><a class="header-anchor" href="#type-system-类型系统">#</a>Type system 类型系统</h1><p>如果你以前见过GraphQL查询，那么你应该知道GraphQL查询语句基本上是选择对象上的字段的。例如，在以下查询中：</p><ol><li>我们从一个特殊的根对象开始</li><li>我们在根对象上选择hero字段</li><li>对于hero返回的对象，我们选择name和appearsln字段。</li></ol><p>因为GraphQL查询的结构和返回的结果非常匹配，所以你可以预测查询将会返回什么，而不需要了解服务器的太多信息。但我们对请求的数据进行准确描述还是很有用的————我们可以选择哪些字段？他们可能会返回什么样的对象？这些子对象上有哪些字段可用？这就是schema模式的来源。</p><p>每个GraphQL服务都定义了一组类型，完全描述了你可以在该服务上查询的数据的类型。然后，当查询来到GraphQL服务上时，将按照该模式对查询进行验证和执行。</p><h1 id="type-language-类型语言"><a class="header-anchor" href="#type-language-类型语言">#</a>Type language 类型语言</h1><p>GraphQL服务可以用任何语言编写。由于我们不能依赖特定的编程语言（如JavaScript）来讨论GraphQL模式，因此我们将定义自己的简单语言。我们将使用“GraphQL模式语言”——它类似于查询语言，并允许我们以不依赖语言的方式讨论GraphQL架构。</p><h1 id="object-types-and-fields-对象类型和字段"><a class="header-anchor" href="#object-types-and-fields-对象类型和字段">#</a>Object types and fields 对象类型和字段</h1><p>GraphQL模式的最基本组件是对象类型，它只表示可以从服务中获取的对象种类，以及它具有哪些字段。在GraphQL模式语言中，我们可以这样表示：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>  <span class="token attr-name">appearsIn</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Episode</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个语言非常易读，但让我们仔细研究一下，这样我们就可以共享词汇了：</p><ul><li><p><code>Character</code>是GraphQL对象类型。这意味着它是一种具有某些字段的类型。模式中的大多数类型都是对象类型。</p></li><li><p><code>name</code>和<code>appearsln</code>是<code>Character</code>类型上的字段。这意味着<code>name</code>和<code>appearsln</code>时唯一可以出现在对<code>Character</code>类型进行操作的GraphQL查询的任何部分中的字段。</p></li><li><p><code>String</code>是内置标量类型之一。这些类型解析为单个标量对象，并且在查询中不能有子选择。稍后我们将进一步讨论标量类型。</p></li><li><p><code>String!</code>表示该字段不可为空，这意味着GraphQL服务承诺在你查询该字段时始终为你提供一个值。在类型语言中，我们将用感叹号表示这些字符。</p></li><li><p><code>[Episode!]!</code>表示<code>Episode</code>对象的数组。由于它也是不可为空的，因此在查询appearsln字段时，你可以期望一个数组（包含零个或多个项）。而且<code>Episode!</code>也是不可为空的，你也可以期望数组中的每个项都是一个<code>Episode</code>对象。</p></li></ul><p>现在你知道了GraphQL对象类型是什么样子，以及如何阅读GraphQL类型语言的基础知识。</p><h1 id="arguments-参数"><a class="header-anchor" href="#arguments-参数">#</a>Arguments 参数</h1><p>GraphQL对象类型上的每个字段都可以有零个或多个参数，例如下面的length字段：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Starship</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>  <span class="token attr-name">length</span><span class="token punctuation">(</span><span class="token attr-name">unit</span><span class="token punctuation">:</span> <span class="token class-name">LengthUnit</span> <span class="token operator">=</span> <span class="token constant">METER</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token scalar">Float</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的参数都需要命名。与JavaScript和Python等语言不同，GraphQL中的所有参数都是按名称传递的。在这种情况下，length字段有一个定义的参数unit。</p><p>参数可以是必须的，也可以是可选的。当一个参数是可选的时候，我们可以设定一个默认值——如果没有传递单位参数，它将默认设置为<code>METER</code>。</p><h1 id="the-query-and-mutation-types-查询和mutation类型"><a class="header-anchor" href="#the-query-and-mutation-types-查询和mutation类型">#</a>The Query and Mutation types 查询和Mutation类型</h1><p>模式中的大多数类型都只是普通对象类型，但模式中有两种类型是特殊的：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">schema</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">query</span><span class="token punctuation">:</span> <span class="token class-name">Query</span>  <span class="token attr-name">mutation</span><span class="token punctuation">:</span> <span class="token class-name">Mutation</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>每个GraphQL服务都有一个查询类型，至于mutation类型不是必须的。这些类型与常规的对象类型相同，但它们很特殊，因为它们定义了每个GraphQL查询的入口。因此，如果你看到类似下面的查询：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span>  <span class="token property-query">droid</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token string">"2000"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"droid"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C-3PO"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这意味着GraphQL服务需要具有带有hero和droid字段的查询类型：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Character</span>  <span class="token attr-name">droid</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Droid</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Mutation的工作方式与此类似——你可以在mutation类型上定义字段，这些字段可以作为查询中可以调用的根mutation字段。</p><p>重点是要记住，除了作为模式的入口之外，查询和mutation类型与其他任何GraphQL对象类型都相同，它们的字段工作方式完全相同。</p><h1 id="scalar-types-标量类型"><a class="header-anchor" href="#scalar-types-标量类型">#</a>Scalar types 标量类型</h1><p>GraphQL对象类型具有名称和字段，但在某些情况下，这些字段必须解析为一些具体数据。这就是标量类型的来源：它们表示查询的结果（叶子）。</p><p>在下面的查询中，name和appearsln字段将解析为标量类型：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">appearsIn</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>        <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>        <span class="token string">"JEDI"</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道这一点是因为这些字段没有任何子字段——它们是查询树的叶子节点。</p><p>GraphQL附带一组现成的默认标量类型：</p><ul><li><code>Int</code>：32位有符号整数</li><li><code>Float</code>：双精度有符号浮点数。</li><li><code>String</code>：utf-8字符串</li><li><code>Boolean</code>：布尔</li><li><code>ID</code>：ID标量类型表示唯一标识符。这通常用于重新提取对象或作为缓存的键。ID类型的序列化方式与<code>String</code>相同；然而，将其定义为<code>ID</code>意味着它不是人类可读的。</li></ul><p>在大多数GraphQL服务实现中，会有自定义标量类型的方法。例如，我们可以定义日期类型：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">scalar</span> <span class="token class-name">Date</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后有我们的实现来定义如何序列化、反序列化和验证该类型。例如，你可以指定Date类型应该始终序列化为整数时间戳，并且你的客户机应该知道任何日期字段都应该使用该格式。</p><h1 id="enumeration-types-枚举类型"><a class="header-anchor" href="#enumeration-types-枚举类型">#</a>Enumeration types 枚举类型</h1><p>枚举类型是一种特殊的标量，仅限于特定的一组允许值。这允许你：</p><ul><li><p>验证此类型的任何参数是否为允许的值之一。</p></li><li><p>通过类型系统通知，该字段始终是一组有限值中的一个。</p></li></ul><p>以下是GraphQL模式语言中的枚举定义：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">enum</span> <span class="token class-name">Episode</span> <span class="token punctuation">&#123;</span>  <span class="token constant">NEWHOPE</span>  <span class="token constant">EMPIRE</span>  <span class="token constant">JEDI</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这意味着，无论我们在模式中使用哪种类型，我们都希望它恰好是<code>NEWHOPE</code>，<code>EMPIRE</code>，<code>JEDI</code>中的某一个。</p><p>请注意，各种语言的GraphQL服务实现都有自己特定于语言的方法处理枚举类型。在支持枚举作为一级公民的语言中，实现可能会利用这一点；在JavaScript这样没有枚举支持的语言中，这些值可能在内部映射到一组整数。然而，这些细节不会泄露给客户端，客户端可以完全按照枚举值的字符串名称进行操作。</p><h1 id="lists-and-non-null-列表和非空"><a class="header-anchor" href="#lists-and-non-null-列表和非空">#</a>Lists and Non-Null 列表和非空</h1><p>对象类型、标量类型和枚举类型是可以在GraphQL中定义的唯一类型。但是，当在模式的其他部分或查询变量声明中使用类型时，可以应用影响这些变量验证的其他类型修饰符。我们来看一个示例：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>  <span class="token attr-name">appearsIn</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Episode</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这，我们使用的是<code>String</code>类型，并通过添加感叹号将其标记为非空。这意味着我们的服务器总是希望为该字段返回一个非空值，如果它最终得到一个空值，那么实际上会触发GraphQL执行错误，让客户端知道出了问题。</p><p>在定义字段的参数的时候也可以使用非空修饰符。如果将空值作为参数传递（无论是在GraphQL字符串中还是在变量中），则会导致GraphQL服务器返回验证错误。</p><p>query</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">DroidById</span><span class="token punctuation">(</span><span class="token variable">$id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">droid</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token variable">$id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>variable</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token property">null</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>result</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Variable \"$id\" of non-null type \"ID!\" must not be null."</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">17</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表的工作方式类似：我们可以使用类型修饰符标记为List，这表示此字段将返回该类型的列表。在模式语言中，这将通过类型包含在方括号[]中来表示。它对参数的作用相同，其中验证步骤需要该值的列表。</p><p>可以同时使用列表和非空修饰符，例如，可以有一个非空字符串列表：</p><pre class="line-numbers language-none"><code class="language-none">myField: [String!]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这表示列表本身可以为空，但是成员不能为空。例如在JSON中：</p><pre class="line-numbers language-none"><code class="language-none">myField: null &#x2F;&#x2F; validmyField: [] &#x2F;&#x2F; validmyField: [&#39;a&#39;, &#39;b&#39;] &#x2F;&#x2F; validmyField: [&#39;a&#39;, null, &#39;b&#39;] &#x2F;&#x2F; error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们又定义了一个非空字符串列表：</p><pre class="line-numbers language-none"><code class="language-none">myField: [String]!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这意味着列表不可为空，但是可以包含空值：</p><pre class="line-numbers language-none"><code class="language-none">myField: null &#x2F;&#x2F; errormyField: [] &#x2F;&#x2F; validmyField: [&#39;a&#39;, &#39;b&#39;] &#x2F;&#x2F; validmyField: [&#39;a&#39;, null, &#39;b&#39;] &#x2F;&#x2F; valid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你可以根据需要任意嵌套使用非空修饰符和列表修饰符。</p><h1 id="interfaces-接口"><a class="header-anchor" href="#interfaces-接口">#</a>Interfaces 接口</h1><p>与许多类型系统一样，GraphQL支持接口。接口是一种抽象类型，它包含一组字段，类型必出包含这些字段才能实现接口。</p><p>例如，你可以有一个Character接口来代表《星球大战》三部曲中的任何角色：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">interface</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>  <span class="token attr-name">friends</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Character</span><span class="token punctuation">]</span>  <span class="token attr-name">appearsIn</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Episode</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这意味着任何实现Character的类型都需要具有这些字段，以及这些参数和返回类型。</p><p>例如，一下是一些可能实现Character的类型。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Human</span> <span class="token keyword">implements</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>  <span class="token attr-name">friends</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Character</span><span class="token punctuation">]</span>  <span class="token attr-name">appearsIn</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Episode</span><span class="token punctuation">]</span><span class="token operator">!</span>  <span class="token attr-name">starships</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Starship</span><span class="token punctuation">]</span>  <span class="token attr-name">totalCredits</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">Droid</span> <span class="token keyword">implements</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span><span class="token operator">!</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>  <span class="token attr-name">friends</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Character</span><span class="token punctuation">]</span>  <span class="token attr-name">appearsIn</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Episode</span><span class="token punctuation">]</span><span class="token operator">!</span>  <span class="token attr-name">primaryFunction</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这两种类型都具有Character接口中的所有字段，但也引入了特定的特定Character类型的额外字段<code>totalCredits</code>、<code>starships</code>和<code>primaryFunction</code>。</p><p>当你想要返回一个或一组对象，但这些对象可能有几种不同的类型的时候，接口会很有用。</p><p>例如，请注意一下查询会产生错误：</p><p>查询</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroForEpisode</span><span class="token punctuation">(</span><span class="token variable">$ep</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable">$ep</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">primaryFunction</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"ep"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"errors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Cannot query field \"primaryFunction\" on type \"Character\". Did you mean to use an inline fragment on \"Droid\"?"</span><span class="token punctuation">,</span>      <span class="token property">"locations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"line"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>          <span class="token property">"column"</span><span class="token operator">:</span> <span class="token number">5</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hero字段返回类型Character，这意味着它可能是Human或者Droif，具体取决于<code>episode</code>参数。在上面的查询中，你只能请求存在于Character接口的字段，该接口不包含<code>primaryFunction</code>。</p><p>想要请求特定对象类型上的字段，需要使用内联片段：</p><p>查询</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroForEpisode</span><span class="token punctuation">(</span><span class="token variable">$ep</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable">$ep</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>      <span class="token property">primaryFunction</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"ep"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"primaryFunction"</span><span class="token operator">:</span> <span class="token string">"Astromech"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在查询中的内联片段部分，请参照<a href="https://graphql.org/learn/queries/#inline-fragments">内联片段</a>章节。</p><h1 id="union-types-联合类型"><a class="header-anchor" href="#union-types-联合类型">#</a>Union types 联合类型</h1><p>联合类型与接口非常相似，但它们不能在类型之间指定任何共享字段。</p><pre class="line-numbers language-none"><code class="language-none">union SearchResult &#x3D; Human | Droid | Starship<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们从模式中返回一个<code>SearchResult</code>类型时，可能会得到一个<code>Human</code>、<code>Droid</code>或<code>Starship</code>。注意，联合类型的成员需要是具体的对象类型，不可以是接口或其他联合类型。</p><p>在这种情况下，如果查询返回<code>SearchResult</code>联合类型的字段，则需要使用内联片段来查询所有字段。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">search</span><span class="token punctuation">(</span><span class="token attr-name">text</span><span class="token punctuation">:</span> <span class="token string">"an"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">__typename</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>      <span class="token property">height</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>      <span class="token property">primaryFunction</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Starship</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>      <span class="token property">length</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"search"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"Human"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span><span class="token punctuation">,</span>        <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">1.8</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"Human"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span><span class="token punctuation">,</span>        <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">1.5</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"Starship"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"TIE Advanced x1"</span><span class="token punctuation">,</span>        <span class="token property">"length"</span><span class="token operator">:</span> <span class="token number">9.2</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__typename</code>字段解析为一个字符串，该字符串允许你在客户端上区分不同的数据类型。</p><p>此外，在本例中，由于<code>Human</code>和<code>Droid</code>共享一个接口（<code>Chatacter</code>），因此可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">search</span><span class="token punctuation">(</span><span class="token attr-name">text</span><span class="token punctuation">:</span> <span class="token string">"an"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">__typename</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>      <span class="token property">height</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>      <span class="token property">primaryFunction</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Starship</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>      <span class="token property">length</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，<code>name</code>仍在<code>Starship</code>上指定，否则它不会显示在结果中，因为<code>Starship</code>不是<code>Character</code>。</p><h1 id="input-types-输入类型"><a class="header-anchor" href="#input-types-输入类型">#</a>Input types 输入类型</h1><p>到目前为止，我们只讨论了标量值（例如枚举和字符串）作为参数传递到字段中。但也可以轻松传递复杂的对象。这在mutation中尤其有价值，因为你可能希望传入一整个要创建的对象。在GraphQL模式语言中，输入类型看起来和常规对象完全相同，但使用<code>input</code>创建而不是<code>type</code>。</p><p>一下是如何在mutation中使用输入类型：</p><p>查询</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">mutation</span> <span class="token definition-mutation function">CreateReviewForEpisode</span><span class="token punctuation">(</span><span class="token variable variable-input">$ep</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token operator">!</span><span class="token punctuation">,</span> <span class="token variable variable-input">$review</span><span class="token punctuation">:</span> <span class="token atom-input class-name">ReviewInput</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query property-mutation">createReview</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable variable-input">$ep</span><span class="token punctuation">,</span> <span class="token attr-name">review</span><span class="token punctuation">:</span> <span class="token variable variable-input">$review</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">stars</span>    <span class="token property">commentary</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"ep"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">,</span>  <span class="token property">"review"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"stars"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token property">"commentary"</span><span class="token operator">:</span> <span class="token string">"This is a great movie!"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"createReview"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"stars"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"commentary"</span><span class="token operator">:</span> <span class="token string">"This is a great movie!"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入类型上的字段本身可以引用输入对象类型，但不能在模式中混合输出和输入类型。输入类型的字段上也不能有参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://graphql.org/learn/schema/#union-types&quot;&gt;Schemas and Types&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇文章中，你将了解有关GraphQL类型系</summary>
      
    
    
    
    <category term="graphql" scheme="http://localhost:5000/categories/graphql/"/>
    
    <category term="schemas" scheme="http://localhost:5000/categories/graphql/schemas/"/>
    
    
    <category term="graphql" scheme="http://localhost:5000/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>rollup插件</title>
    <link href="http://localhost:5000/2022/12/16/rollup-plugin/"/>
    <id>http://localhost:5000/2022/12/16/rollup-plugin/</id>
    <published>2022-12-16T06:02:55.000Z</published>
    <updated>2022-12-16T07:40:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://rollupjs.org/guide/en/#plugin-development">rollup 插件</a>翻译</p></blockquote><h1 id="插件概述"><a class="header-anchor" href="#插件概述">#</a>插件概述</h1><p>一个rollup插件是一个具有一个或多个属性，构建hook和输出生成hook的对象插件应作为一个包分发，该包导出一个函数，该函数可以使用插件特定的option调用并返回这样的对象。</p><p>插件允许你自定义rollup的行为，例如，在绑定之前传输代码，或在node_modules文件夹中查找第三方模块。有关如何使用插件的示例，请查看<a href="https://rollupjs.org/guide/en/#using-plugins">Using plugins</a>。</p><p>可以在<a href="https://github.com/rollup/awesome">github.com/rollup/awesome</a>上找到一个插件列表。如果你想对插件提出建议，请提交一个PR。</p><h1 id="简单示例"><a class="header-anchor" href="#简单示例">#</a>简单示例</h1><p>下面的插件在不访问文件系统的情况下拦截任何虚拟模块的导入。例如，如果你想在浏览器中使用rollup，这是必要的。它甚至可以用于替换示例中所示的entry points。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// rollup-plugin-my-example.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">myExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'my-example'</span><span class="token punctuation">,</span> <span class="token comment">// this name will show up in warnings and errors</span>    <span class="token function">resolveId</span> <span class="token punctuation">(</span> <span class="token parameter">source</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token operator">===</span> <span class="token string">'virtual-module'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> source<span class="token punctuation">;</span> <span class="token comment">// this signals that rollup should not ask other plugins or check the file system to find this id</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// other ids should be handled as usually</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function">load</span> <span class="token punctuation">(</span> <span class="token parameter">id</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">===</span> <span class="token string">'virtual-module'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'export default "This is virtual!"'</span><span class="token punctuation">;</span> <span class="token comment">// the source code for "virtual-module"</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// other ids should be handled as usually</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// rollup.config.js</span><span class="token keyword">import</span> myExample <span class="token keyword">from</span> <span class="token string">'./rollup-plugin-my-example.js'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token literal-property property">input</span><span class="token operator">:</span> <span class="token string">'virtual-module'</span><span class="token punctuation">,</span> <span class="token comment">// resolved by our plugin</span>  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">myExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">file</span><span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>    <span class="token literal-property property">format</span><span class="token operator">:</span> <span class="token string">'es'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="惯例"><a class="header-anchor" href="#惯例">#</a>惯例</h1><ul><li>插件应该有一个清晰的名字，带有rollup-plugin- 的前缀。</li><li>在package.json文件中包含rollup-plugin关键字。</li><li>插件应该经过测试。我们推荐<a href="https://github.com/mochajs/mocha">mocha</a>，或者<a href="https://github.com/avajs/ava">ava</a>，它们支持开箱即用的Promise。</li><li>如果可能，请使用异步方法，例如使用fs.reafFile而不是fs.reafFileSync。</li><li>使用英语书写文档。</li><li>如果合适，请确认你的插件输出正确的源映射。</li><li>如果你的插件使用“虚拟模块”（例如，helper函数），请在模块ID前加上\0。这将阻止其他插件尝试处理它。</li></ul><h1 id="properties-属性"><a class="header-anchor" href="#properties-属性">#</a>Properties 属性</h1><h2 id="name"><a class="header-anchor" href="#name">#</a>name</h2><p>Type: string<br>插件的名字，用于error和warning信息中。</p><h1 id="build-hooks-构建hook"><a class="header-anchor" href="#build-hooks-构建hook">#</a>Build Hooks 构建Hook</h1><p>为了与构建过程交互，插件对象需要包含hook。hook是在构建的各个阶段调用的函数。hook可以影响构建的运行，提供有关构建的信息，或者在构建完成之后进行修改。这有不同种类的hook：</p><ul><li>async：这种hook可以返回一个Promise，解析为相同类型的值；否则，这个hook应该标记为sync。</li><li>first：如果几个插件都实现了这个hook，hook将按顺序执行，直到hook返回null或undefined以外的值。</li><li>sequential：如果几个插件实现了这个hook，那么这些插件都将按照指定的插件顺序执行。如果其中一个hook是异步的，那么这种类型的后续hook将等待当前hook执行完毕。</li><li>parallel：如果有几个插件实现了这个hook，那么这些插件都将按照执行的插件顺序执行。如果一个hook是异步的，那么这种类型的后续hook将并行执行，而不是等待当前hook。</li></ul><p>hook不仅可以是对象，也可以是函数。在这种情况下，必须将实际的hook函数（或者banner/footer/intro/outro的值）指定为处理程序。这允许你提供更改hook执行的其他可选属性。</p><ul><li>order: “pre” | “post” | null</li></ul><p>如果有几个插件实现了这个hook，要么先运行这个插件(‘pre’)，要么最后运行(‘post’)，或者在用户执行的顺序运行(没有值或者为null)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">resolveFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'resolve-first'</span><span class="token punctuation">,</span>    <span class="token literal-property property">resolveId</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">order</span><span class="token operator">:</span> <span class="token string">'pre'</span><span class="token punctuation">,</span>      <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">source</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token operator">===</span> <span class="token string">'external'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> source<span class="token punctuation">,</span> <span class="token literal-property property">external</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果几个插件都使用了‘pre’或’post’，rollup将按照用户指定的顺序运行它们。此选项可用于所有插件hook。对于并行hook，它会更改hook的同步部分的运行顺序。</p><ul><li>sequential: boolean</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://rollupjs.org/guide/en/#plugin-development&quot;&gt;rollup 插件&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;插件概述&quot;&gt;&lt;a class=&quot;header</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="rollup" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/rollup/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="rollup" scheme="http://localhost:5000/tags/rollup/"/>
    
  </entry>
  
  <entry>
    <title>graphql-queries-mutations</title>
    <link href="http://localhost:5000/2022/12/15/graphql-queries-mutations/"/>
    <id>http://localhost:5000/2022/12/15/graphql-queries-mutations/</id>
    <published>2022-12-15T03:42:35.000Z</published>
    <updated>2023-01-09T06:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://graphql.org/learn/queries/">Queries and Mutations</a>翻译</p></blockquote><p>在这篇文章里，你会学到如何进行GraphQL的查询的细节。</p><h1 id="fields-字段"><a class="header-anchor" href="#fields-字段">#</a>Fields 字段</h1><p>简而言之，GraphQL就是查询对象上的特定字段。让我们从一个非常简单的查询以及运行它的结果开始：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以直观发现查询和结果的结构完全相同。这对于GraphQL至关重要，因为这使得你总是得到需要的信息，并且服务端明确知道客户端的所需字段。<br>字段返回了一个字符串类型。本例中是《星球大战》的主要英雄的名字，“R2-D2”。</p><blockquote><p>哦，还有一件事——上面的查询是交互式的。这意味着你可以随心所欲地改变他，并得到新的结果。尝试向查询中的hero对象添加appearsln字段，然后查看新结果。<br>还是去原网页试试吧。。</p></blockquote><p>在上个例子中，我们只是查询了hero的name字段，但字段也可以引用对象。在这种情况下，可以为该对象进行字段的子查询。GraphQL查询可以遍历相关对象及其字段，让客户端在一个请求中获取大量相关数据，而不是像传统REST架构中那样进行多次往返。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token comment"># Queries can have comments!</span>    <span class="token object">friends</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，在这个例子中，friends字段返回一个项目列表。GraphQL查询对于单个项目或项目列表都是相同的；然而，我们根据schema中所指示的内容，知道应该选择那个。</p><h1 id="arguments-参数"><a class="header-anchor" href="#arguments-参数">#</a>Arguments 参数</h1><p>如果我们唯一能做的就是遍历对象及其字段，GraphQL不过就是一种有非常有用的获取数据的语言。但是当它有了向字段传递参数的动能时，事情就会变得更加有趣了。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">human</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token string">"1000"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">height</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"human"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>      <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">1.72</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在REST这样的系统中，你只能传递一组参数，即请求中的查询参数和url字段。但是在GraphQL中，每个字段和嵌套对象中都可以获得自己的一套参数，使得GraphQL完全可以替代多个API请求。你甚至可以将参数传递到标量字段中，在服务端实现一次数据转换，而不是在客户端实现。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">human</span><span class="token punctuation">(</span><span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token string">"1000"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property-query">height</span><span class="token punctuation">(</span><span class="token attr-name">unit</span><span class="token punctuation">:</span> <span class="token constant">FOOT</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"human"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>      <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">5.6430448</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数可以有许多不同的类型。在上面的示例中，我们使用了Enumeration枚举类型，它表示一组有限的选项（在本例中，长度单位为METER或FOOT）。GraphQL附带一组默认类型，但GraphQL服务端也可以声明自己的自定义类型，只要它们可以序列化为传输格式即可。</p><p><a href="https://graphql.org/learn/schema">这里阅读更多有关GraphQL类型系统</a></p><h1 id="aliases-别名"><a class="header-anchor" href="#aliases-别名">#</a>Aliases 别名</h1><p>如果你目光敏锐，可能已经注意到，由于结果对象字段与查询字段名称匹配，但不包含参数，因此不能直接查询具有不同参数的同一字段。这就是为什么需要别名从原因——它们允许你将字段的结果重命名为所需的任何名称。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token attr-name">empireHero</span><span class="token punctuation">:</span> <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token constant">EMPIRE</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span>  <span class="token attr-name">jediHero</span><span class="token punctuation">:</span> <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token constant">JEDI</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"empireHero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"jediHero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，两个hero字段可能会冲突，但由于我们使用了别名，因此可以在一个请求中获得两个结果。</p><h1 id="fragments-片段"><a class="header-anchor" href="#fragments-片段">#</a>Fragments 片段</h1><p>假设我们的应用程序有一个比较复杂的页面，可以让我们并排查看两位hero以及他们的朋友。你可以想象，这样的查询可能很快变得复杂，因为我们至少需要重复字段一次——比较的每一侧都需要重复一次。<br>这就是GraphQL使用了被称为片段的可复用单元的原因。片段允许你构建字段集，然后再需要时将它们包含在查询中，下面是如何使用片段的例子：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token attr-name">leftComparison</span><span class="token punctuation">:</span> <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token constant">EMPIRE</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">comparisonFields</span>  <span class="token punctuation">&#125;</span>  <span class="token attr-name">rightComparison</span><span class="token punctuation">:</span> <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token constant">JEDI</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">comparisonFields</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fragment</span> <span class="token fragment function">comparisonFields</span> <span class="token keyword">on</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token property">name</span>  <span class="token property">appearsIn</span>  <span class="token object">friends</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"leftComparison"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>      <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>        <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>        <span class="token string">"JEDI"</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C-3PO"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"rightComparison"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"appearsIn"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"NEWHOPE"</span><span class="token punctuation">,</span>        <span class="token string">"EMPIRE"</span><span class="token punctuation">,</span>        <span class="token string">"JEDI"</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，如果重复这些片段，上面的查询会变得非常复杂。片段的概念通常用于将复杂的应用程序数据需求切分成更小的块，特别是当你需要将具有不同片段的大量UI组件则合成一个初始数据请求时。</p><h2 id="using-variables-inside-fragments-在片段中使用变量"><a class="header-anchor" href="#using-variables-inside-fragments-在片段中使用变量">#</a>Using variables inside fragments 在片段中使用变量</h2><p>片段中可以访问查询或mutation中声明的变量。参见<a href="https://graphql.org/learn/queries/#variables">变量</a></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroComparison</span><span class="token punctuation">(</span><span class="token variable">$first</span><span class="token punctuation">:</span> <span class="token scalar">Int</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">leftComparison</span><span class="token punctuation">:</span> <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token constant">EMPIRE</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">comparisonFields</span>  <span class="token punctuation">&#125;</span>  <span class="token attr-name">rightComparison</span><span class="token punctuation">:</span> <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token constant">JEDI</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token fragment function">comparisonFields</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fragment</span> <span class="token fragment function">comparisonFields</span> <span class="token keyword">on</span> <span class="token class-name">Character</span> <span class="token punctuation">&#123;</span>  <span class="token property">name</span>  <span class="token property-query">friendsConnection</span><span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token variable">$first</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">totalCount</span>    <span class="token object">edges</span> <span class="token punctuation">&#123;</span>      <span class="token object">node</span> <span class="token punctuation">&#123;</span>        <span class="token property">name</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"leftComparison"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span><span class="token punctuation">,</span>      <span class="token property">"friendsConnection"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"totalCount"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>        <span class="token property">"edges"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"C-3PO"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">]</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token property">"rightComparison"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"friendsConnection"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"totalCount"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>        <span class="token property">"edges"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">]</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="operation-name-操作名"><a class="header-anchor" href="#operation-name-操作名">#</a>Operation name 操作名</h1><p>到目前为止，我们一直使用一种省略关键字和查询名称的缩略语法。但在实际生产应用程序中，使用关键字和查询名称语法可以减少代码的歧义。<br>下面是一个例子，其中包含关键字查询作为操作类型，HeroNameAndFriends作为操作名称。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroNameAndFriends</span> <span class="token punctuation">&#123;</span>  <span class="token object">hero</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token object">friends</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作类型是查询，mutaition，以及订阅，并描述你要执行的操作类型。除非你使用查询的简略语法，操作类型是必须的。在这种情况下，你无法为操作提供名称或者变量定义。</p><p>操作名称是操作的一个显式的有意义的名称。它只在多操作文档中是必须的，但我们推荐使用，因为它对于调试和服务端日志记录非常有用。当出问题（你在网络日志或者GraphQL服务日志中看到错误）时，通过操作名称找到代码中出问题的查询的位置，要比试图破解内容更容易。把它想象成你最喜欢的编程语言的一个函数名。例如，在JavaScript中，我们可以只使用匿名函数工作，但当我们为函数命名时，更容易追踪它，调试代码，并在调用时记录。同样，GraphQL查询和mutation名，以及片段名称，可以是在服务端识别不同GraphQL请求的有力的调试工具。</p><h1 id="variables-变量"><a class="header-anchor" href="#variables-变量">#</a>Variables 变量</h1><p>到目前为止，我们已经在查询中写入了所有参数。但在大多数应用程序中，字段的参数是动态的。例如，可能有一个下拉列表，让你选择最感兴趣的《星球大战》剧集，或者一个搜索字段，或者一组过滤器。</p><p>直接在查询语句中传递这些动态参数不会是一个好主意，因为这样我们的客户端代码需要在运行时动态操作查询语句，并将其序列化为GraphQL特定格式。取而代之，GraphQL有一种一流的方式，将动态值从查询语句中分离出来，并将它们作为单独的字典传递。这些值被称为变量。</p><p>当我们开始处理变量时，需要做三件事：</p><ol><li>用$variableName替换查询中的静态值</li><li>将$variable声明为查询接受的变量之一</li><li>传递variableName：单独的，适于传输的（通常是JSON）变量字典中的值。</li></ol><p>这是它们一起工作的例子：</p><p>查询语句</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroNameAndFriends</span><span class="token punctuation">(</span><span class="token variable">$episode</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable">$episode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token object">friends</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量值</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"episode"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"friends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，在我们的客户点代码中，可以简单地传送一个不同的变量，而不是需要构建一个全新的查询语句。一般来说这是一个很好的做法，可以用来表示查询中那些参数是动态的——我们不应该使用字符串插值添加用户的值来构建查询语句。</p><h2 id="variable-definitions-变量定义"><a class="header-anchor" href="#variable-definitions-变量定义">#</a>Variable definitions 变量定义</h2><p>变量定义是在上面的查询中看起来像（$episode: Episode）的部分。它的工作方式与类型化语言中函数参数的定义方式相同。它列出了所有变量，前缀是$，后面是它的类型，在本例中为Episode。</p><p>所有声明的变量必须是标量，枚举或者输入对象类型。因此，如果你想要传递一个复杂的对象到一个字段中，需要知道服务端上匹配的输入类型。在Schema模式页面上了解更多输入对象类型的相关信息。</p><p>变量定义成可以是可选的，也可以是必须的。在上面的例子中，因为在Episode类型后没有!符号，它就是可选的。但如果变量传递到在字段需要非空参数，那么也必须要传递给变量。</p><p>想要进一步了解这些变量定义的语法，学习GraphQL模式语言很有用。模式语言在Schema页面有详细说明。</p><h2 id="default-variables-默认变量"><a class="header-anchor" href="#default-variables-默认变量">#</a>Default variables 默认变量</h2><p>在类型声明之后可以添加默认值，也可以将默认值分配给查询中的变量。</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroNameAndFriends</span><span class="token punctuation">(</span><span class="token variable">$episode</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span> <span class="token operator">=</span> <span class="token constant">JEDI</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable">$episode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token object">friends</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当为所有变量提供默认值时，你可以在不传递任何变量的条件下调用查询。如果任何变量作为变量字典的一部分传递，它们将覆盖默认值。</p><h1 id="directives-指令"><a class="header-anchor" href="#directives-指令">#</a>Directives 指令</h1><p>我们之前讨论了如何使用变量来避免使用字符串插值的方式构建动态查询。通过在参数中传递变量解决了大部分此类问题，但我们可能还需要另一种方法来动态改变查询的结构和形状。例如，我们可以想象一个UI组件，它有一个详细的汇总视图，其中一个包含的字段多余另一个。</p><p>让我们为这样的一个组件构建一个查询：</p><p>查询语句:</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">Hero</span><span class="token punctuation">(</span><span class="token variable">$episode</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token punctuation">,</span> <span class="token variable">$withFriends</span><span class="token punctuation">:</span> <span class="token scalar">Boolean</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable">$episode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token property">friends</span> <span class="token directive function">@include</span><span class="token punctuation">(</span><span class="token attr-name">if</span><span class="token punctuation">:</span> <span class="token variable">$withFriends</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"episode"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">,</span>  <span class="token property">"withFriends"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查询结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尝试修改上面的变量，将withFriends修改为true，并查看结果如何变化(去原网页试试吧)。</p><p>我们需要在GraphQL中使用一个名为指令的特性。指令可以用在字段或者片段中，并且可以以服务器希望的任何方式影响查询的执行。GraphQL核心规范仅包含两个指令，任何符合规范的GraphQL服务器都必须支持这两个指令:</p><ul><li>@include(if: Boolean) 仅当参数为true时，才在结果中包含此字段。</li><li>@skip(if: Boolean) 如果参数为真，则跳过此字段。</li></ul><p>指令对于需要改变查询字段是需要进行字符串操作的情况非常有用。服务器还可以自定义全新的指令来增添实验性功能。</p><h1 id="mutations"><a class="header-anchor" href="#mutations">#</a>Mutations</h1><p>GraphQL大多数讨论都集中在获取数据上，但任何完整的数据平台都需要一种修改服务端数据的方案。</p><p>在REST中，任何请求都可能会对服务器产生一些副作用，但按照惯例，不会使用GET请求来修改数据。GraphQL与此类似——从技术讲任何查询都可以实现数据写入。然而，我们还是构建了一个惯例，任何导致写入的操作推荐显式地发送请求。</p><p>就像查询一样，如果mutation字段返回对象类型，则可以请求嵌套字段。这对于获取更新后对象的新状态非常有用。让我们看一下一个简单的mutation示例：</p><p>mutation:</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">mutation</span> <span class="token definition-mutation function">CreateReviewForEpisode</span><span class="token punctuation">(</span><span class="token variable variable-input">$ep</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token operator">!</span><span class="token punctuation">,</span> <span class="token variable variable-input">$review</span><span class="token punctuation">:</span> <span class="token atom-input class-name">ReviewInput</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query property-mutation">createReview</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable variable-input">$ep</span><span class="token punctuation">,</span> <span class="token attr-name">review</span><span class="token punctuation">:</span> <span class="token variable variable-input">$review</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">stars</span>    <span class="token property">commentary</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"ep"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">,</span>  <span class="token property">"review"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"stars"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token property">"commentary"</span><span class="token operator">:</span> <span class="token string">"This is a great movie!"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"createReview"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"stars"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>      <span class="token property">"commentary"</span><span class="token operator">:</span> <span class="token string">"This is a great movie!"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意createReview字段如何返回新创建的commentary和star字段。这在mutation现有数据时十分有用。例如，当增加字段时，我们可以通过一个请求来mutation和查询字段的新值。</p><p>你可能还注意到，在这个例子中，我们传递的review变量不是标量。他是一种输入对象类型，一种可以作为参数传入的特殊类型的对象类型。在Schema页面上了解有关输入类型的更多信息。</p><h2 id="multiple-fields-in-mutations-mutation中的多个字段"><a class="header-anchor" href="#multiple-fields-in-mutations-mutation中的多个字段">#</a>Multiple fields in mutations Mutation中的多个字段</h2><p>Mutation可以包含多个字段，就像查询一样。查询和mutation之间有一个重要差别，除了名称之外：</p><blockquote><p>查询字段可以并列执行，mutation字段只能一个一个地串行执行。</p></blockquote><p>这意味着，如果我们在一个请求中发送两个incrementCredits的mutation，第一个保证在第二个开始之前完成，从而保证我们不会与自己产生竞争冲突条件。</p><h1 id="inline-fragments-内联片段"><a class="header-anchor" href="#inline-fragments-内联片段">#</a>Inline Fragments 内联片段</h1><p>与其他许多类型系统一样，GraphQL Schema包括定义接口和联合类型的能力。在<a href="https://graphql.org/learn/schema/#interfaces">模式指南</a>中了解它们。</p><p>如果要查询返回接口或联合类型的字段，则需要使用内联片段来访问基础具体类型上的数据。举个例子：</p><p>查询字段</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token definition-query function">HeroForEpisode</span><span class="token punctuation">(</span><span class="token variable">$ep</span><span class="token punctuation">:</span> <span class="token class-name">Episode</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token property-query">hero</span><span class="token punctuation">(</span><span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token variable">$ep</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>      <span class="token property">primaryFunction</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>      <span class="token property">height</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"ep"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"hero"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"R2-D2"</span><span class="token punctuation">,</span>      <span class="token property">"primaryFunction"</span><span class="token operator">:</span> <span class="token string">"Astromech"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个查询中，hero字段返回类型Character，该类型可能是Human或Droid，具体取决于episode参数。在直接选择中，你只能询问Character界面上存在的字段，例如name。</p><p>要请求具体类型上的字段，需要使用带有类型条件的内联片段。因为第一个片段在Droid上标记为…，所以只有当从hero返回的角色是Droid类型时，才会执行primaryFunction字段。对于Human类型的height字段也是如此。</p><p>命名片段也可以以相同的方式使用。因为命名片段总是附带一个类型。</p><h2 id="meta-fields-元字段"><a class="header-anchor" href="#meta-fields-元字段">#</a>Meta fields 元字段</h2><p>考虑到在某些情况下，你不知道从GraphQL服务器上返回什么类型的数据，你需要一些方法确认如何在客户端上处理这些数据。GraphQL允许你请求_typename，一个元字段，以获取该点的对象类型的名称。</p><p>查询</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token property-query">search</span><span class="token punctuation">(</span><span class="token attr-name">text</span><span class="token punctuation">:</span> <span class="token string">"an"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token property">__typename</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Human</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Droid</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">...</span> <span class="token keyword">on</span> <span class="token class-name">Starship</span> <span class="token punctuation">&#123;</span>      <span class="token property">name</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"search"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"Human"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Han Solo"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"Human"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Leia Organa"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"Starship"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"TIE Advanced x1"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的查询中，搜索返回一个联合类型，他可以是三个选项之一。如果没有_typename字段，就无法区分客户端的不同类型。</p><p>GraphQL服务提供了几个元字段，其他的用于公开<a href="https://graphql.org/learn/introspection/">Introspection</a>系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://graphql.org/learn/queries/&quot;&gt;Queries and Mutations&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇文章里，你会学到如何进行GraphQL的查询的细节。&lt;</summary>
      
    
    
    
    <category term="graphql" scheme="http://localhost:5000/categories/graphql/"/>
    
    <category term="query" scheme="http://localhost:5000/categories/graphql/query/"/>
    
    
    <category term="graphql" scheme="http://localhost:5000/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to GraphQL翻译</title>
    <link href="http://localhost:5000/2022/12/15/graphql-introduction/"/>
    <id>http://localhost:5000/2022/12/15/graphql-introduction/</id>
    <published>2022-12-15T02:52:21.000Z</published>
    <updated>2022-12-15T03:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://graphql.org/learn/">Introduction to GraphQL</a>翻译</p></blockquote><h1 id="graphql简介"><a class="header-anchor" href="#graphql简介">#</a>graphql简介</h1><blockquote><p>想要了解GraphQL是如何工作的，如何使用的？在查找如何构建一个GraphQL服务的文档？这里的库能够帮助你使用<a href="https://graphql.org/code/">不同的编程语言</a>实现GraphQL。如果想进行实用教程的深入学习，请看<a href="https://www.howtographql.com/">How to GraphQL</a>。如果想查看免费在线教程，<a href="https://www.edx.org/course/exploring-graphql-a-query-language-for-apis">Exploring GraphQL: A Query Language for APIs</a></p></blockquote><p>GraphQL是一种API的查询语言，也是一种为了类型定义的数据系统执行查询服务的服务端运行时。GraphQL没有绑定到任何特定的数据库或存储引擎，而是由你的现有代码和数据支持。</p><p>创建GraphQL服务，是通过在类型上定义类型和字段，然后为每个类型上的每个字段提供函数实现的。l例如，一个告诉你登录用户是谁（用户的名字）的GraphQL服务可能如下所示：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">me</span><span class="token punctuation">:</span> <span class="token class-name">User</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>  <span class="token attr-name">id</span><span class="token punctuation">:</span> <span class="token scalar">ID</span>  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个类型上的每个字段的函数如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">Query_me</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> request<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>user<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">User_name</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GraphQL服务运行后（通常是在web服务的URL上），它可以接收GraphQL查询来进行验证和执行。服务首先会检查查询请求，确认它只使用了已定义的类型和字段，然后运行提供函数来生成结果。</p><p>例如，如下查询：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"><span class="token punctuation">&#123;</span>  <span class="token object">me</span> <span class="token punctuation">&#123;</span>    <span class="token property">name</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会产生如下的JSON查询结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"me"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Luke Skywalker"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要了解更过，点击继续阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://graphql.org/learn/&quot;&gt;Introduction to GraphQL&lt;/a&gt;翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;graphql简介&quot;&gt;&lt;a class=&quot;header-anc</summary>
      
    
    
    
    <category term="graphql" scheme="http://localhost:5000/categories/graphql/"/>
    
    <category term="introduction" scheme="http://localhost:5000/categories/graphql/introduction/"/>
    
    
    <category term="graphql" scheme="http://localhost:5000/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>petite-vue学习记录2</title>
    <link href="http://localhost:5000/2022/12/14/petite-vue-learn-2/"/>
    <id>http://localhost:5000/2022/12/14/petite-vue-learn-2/</id>
    <published>2022-12-13T16:15:26.000Z</published>
    <updated>2022-12-14T05:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="petite-vue-调用流程"><a class="header-anchor" href="#petite-vue-调用流程">#</a>petite-vue 调用流程</h1><p>目录结构</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(venv) <span class="built_in">PS</span> F:\lite\petite<span class="literal">-vue</span>\src&gt; tree /f</span><br><span class="line">文件夹 PATH 列表</span><br><span class="line">卷序列号为 <span class="number">0123</span><span class="literal">-4567</span></span><br><span class="line">F:.</span><br><span class="line">│  app.ts</span><br><span class="line">│  block.ts</span><br><span class="line">│  context.ts</span><br><span class="line">│  eval.ts</span><br><span class="line">│  index.ts</span><br><span class="line">│  scheduler.ts</span><br><span class="line">│  utils.ts</span><br><span class="line">│  walk.ts</span><br><span class="line">│</span><br><span class="line">└─directives</span><br><span class="line">        bind.ts</span><br><span class="line">        effect.ts</span><br><span class="line">        for.ts</span><br><span class="line">        html.ts</span><br><span class="line">        if.ts</span><br><span class="line">        index.ts</span><br><span class="line">        model.ts</span><br><span class="line">        on.ts</span><br><span class="line">        ref.ts</span><br><span class="line">        show.ts</span><br><span class="line">        text.ts</span><br></pre></td></tr></table></figure><p>大致来说，</p><ol><li>从<code>index.ts</code>中导出各种东西，包括在<code>app.ts</code>中的<code>createApp</code>。</li><li>然后创建<code>app</code>实例。过程中，首先通过<code>context.ts</code>创建了<code>ctx</code>对象，保管创建<code>createApp</code>时的一些参数。</li><li>然后调用<code>mount</code>方法，挂载在dom节点上。首先会找一个<code>root</code>节点列表。也就是有<code>v-scope</code>属性的那种。</li><li>然后调用<code>block.ts</code>的<code>Block</code>。过程中会检查是否是<code>root</code>节点列表中的根节点。</li><li>然后调用<code>walk.ts</code>中的<code>walk</code>，不断检查所有节点。</li><li>检查节点过程中检查所有的指令，就是<code>directives</code>文件夹下那种。</li><li>调用对应指令，通过<code>ctx.effect</code>之类的。调用之后会将其保存。如果需要响应式调用会调用响应函数，完成响应式应答。</li></ol><p>至于响应式原理，不在这里。可以看看<code>@vue/reactivity</code>？</p><h1 id="index-ts"><a class="header-anchor" href="#index-ts">#</a>index.ts</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;./scheduler&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="variable language_">document</span>.<span class="property">currentScript</span></span><br><span class="line"><span class="keyword">if</span> (s &amp;&amp; s.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;init&#x27;</span>)) &#123;</span><br><span class="line">  <span class="title function_">createApp</span>().<span class="title function_">mount</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暴露了<code>createApp</code>，<code>nextTick</code>，<code>reactive</code>，三个接口。<br><code>createApp</code>用于创建<code>app</code>实例。<br><code>nextTick</code>用于解决响应式不能立即应答的问题。<br><code>reactive</code>暴露vue的响应式变量创建接口。</p><h1 id="app-ts"><a class="header-anchor" href="#app-ts">#</a>app.ts</h1><p>核心就是<code>createApp</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createApp = <span class="keyword">function</span>(<span class="params">initialData</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">directive</span>:()&#123;&#125;,</span><br><span class="line"><span class="attr">mount</span>:()&#123;&#125;,</span><br><span class="line"><span class="attr">unmount</span>:()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createapp初始化"><a class="header-anchor" href="#createapp初始化">#</a>createApp初始化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root context</span></span><br><span class="line"><span class="keyword">const</span> ctx = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">if</span> (initialData) &#123;</span><br><span class="line">  ctx.<span class="property">scope</span> = <span class="title function_">reactive</span>(initialData)</span><br><span class="line">  <span class="title function_">bindContextMethods</span>(ctx.<span class="property">scope</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// handle custom delimiters</span></span><br><span class="line">  <span class="keyword">if</span> (initialData.<span class="property">$delimiters</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [open, close] = (ctx.<span class="property">delimiters</span> = initialData.<span class="property">$delimiters</span>)</span><br><span class="line">    ctx.<span class="property">delimitersRE</span> = <span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">      escapeRegex(open) + <span class="string">&#x27;([^]+?)&#x27;</span> + escapeRegex(close),</span><br><span class="line">      <span class="string">&#x27;g&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global internal helpers</span></span><br><span class="line">ctx.<span class="property">scope</span>.<span class="property">$s</span> = toDisplayString</span><br><span class="line">ctx.<span class="property">scope</span>.<span class="property">$nextTick</span> = nextTick</span><br><span class="line">ctx.<span class="property">scope</span>.<span class="property">$refs</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">rootBlocks</span>: <span class="title class_">Block</span>[]</span><br></pre></td></tr></table></figure><p>首先是使用<code>context.ts</code>中的<code>createContext</code>方法创建了一个<code>ctx</code>对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  key?: <span class="built_in">any</span> <span class="comment">// 不清楚有什么用</span></span><br><span class="line">  <span class="attr">scope</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; <span class="comment">// 响应式对象存放</span></span><br><span class="line">  <span class="attr">dirs</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Directive</span>&gt; <span class="comment">// 存放自定义指令</span></span><br><span class="line">  <span class="attr">blocks</span>: <span class="title class_">Block</span>[] <span class="comment">// 不是由根创建的Block实例，会把创建的Block实例向添加到ctx对象中这个属性中</span></span><br><span class="line">  <span class="attr">effect</span>: <span class="keyword">typeof</span> rawEffect <span class="comment">// 一个函数，会把指令生成的响应式函数注入到ctx对象中。</span></span><br><span class="line">  <span class="attr">effects</span>: <span class="title class_">ReactiveEffectRunner</span>[] <span class="comment">// 所谓的响应式函数存放处，和react的effect类似</span></span><br><span class="line">  <span class="attr">cleanups</span>: (<span class="function">() =&gt;</span> <span class="built_in">void</span>)[] <span class="comment">// 不清楚有什么用</span></span><br><span class="line">  <span class="attr">delimiters</span>: [<span class="built_in">string</span>, <span class="built_in">string</span>] <span class="comment">// 分隔符，可以自定义。</span></span><br><span class="line">  <span class="attr">delimitersRE</span>: <span class="title class_">RegExp</span> <span class="comment">// 分隔符对应的一个正则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是处理<code>initialData</code><br>将<code>initialData</code>响应式化，然后存到<code>ctx</code>的scope中。<br><code>bindContextMethods</code>将<code>ctx.scope</code>下的函数的<code>this</code>绑定到<code>ctx.scope</code>上。</p><p>然后是对<code>ctx.scope</code>进行一些绑定。</p><p>最后创建了一个<code>rootBlocks</code>列表。<br>在返回值中会用到。</p><h2 id="directive"><a class="header-anchor" href="#directive">#</a>directive</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">directive</span>(<span class="params">name: <span class="built_in">string</span>, def?: Directive</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (def) &#123;</span><br><span class="line">        ctx.<span class="property">dirs</span>[name] = def</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="property">dirs</span>[name]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>将指令定义函数存放到<code>ctx.dirs</code>中。<br>如果没有输入<code>def</code>参数，则返回<code>ctx.dirs[name]</code>。</p><h2 id="mount"><a class="header-anchor" href="#mount">#</a>mount</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mount</span>(<span class="params">el?: <span class="built_in">string</span> | Element | <span class="literal">null</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el)</span><br><span class="line">        <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">          <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">DEV</span> &amp;&amp;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`selector <span class="subst">$&#123;el&#125;</span> has no matching element.`</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      el = el || <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">      <span class="keyword">let</span> <span class="attr">roots</span>: <span class="title class_">Element</span>[]</span><br><span class="line">      <span class="keyword">if</span> (el.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-scope&#x27;</span>)) &#123;</span><br><span class="line">        roots = [el]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        roots = [...el.<span class="title function_">querySelectorAll</span>(<span class="string">`[v-scope]`</span>)].<span class="title function_">filter</span>(</span><br><span class="line">          <span class="function">(<span class="params">root</span>) =&gt;</span> !root.<span class="title function_">matches</span>(<span class="string">`[v-scope] [v-scope]`</span>)</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!roots.<span class="property">length</span>) &#123;</span><br><span class="line">        roots = [el]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">DEV</span> &amp;&amp;</span><br><span class="line">        roots.<span class="property">length</span> === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        roots[<span class="number">0</span>] === <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Mounting on documentElement - this is non-optimal as petite-vue `</span> +</span><br><span class="line">            <span class="string">`will be forced to crawl the entire page&#x27;s DOM. `</span> +</span><br><span class="line">            <span class="string">`Consider explicitly marking elements controlled by petite-vue `</span> +</span><br><span class="line">            <span class="string">`with \`v-scope\`.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      rootBlocks = roots.<span class="title function_">map</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Block</span>(el, ctx, <span class="literal">true</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>首先是处理<code>el</code>参数。</p><p>如果是<code>string</code>类型，则使用<code>el.querySelectorAll</code>查找所有dom节点。<br>如果是<code>null</code>，则默认为<code>html</code>节点。<br>如果是<code>Element</code>，不予处理</p><p>然后是生成<code>roots</code><br>如果<code>el</code>节点带有<code>v-scope</code>属性，则<code>roots = [el]</code>。<br>否则<code>roots</code>为<code>el</code>节点下有<code>v-scope</code>属性的dom节点。<br>如果<code>el</code>节点下没有属性<code>v-scope</code>的节点，则<code>roots = [el]</code>。</p><p>接下来检查<code>warn</code>。<br>如果在构建工具中处于开发模式，并且<code>el</code>参数为<code>null</code>,并且没有使用<code>v-scope</code>。<br>则发出警告。</p><p>最后创建<code>Block</code>实例。<br>输入<code>el</code>dom节点，<code>ctx</code>对象，<code>isRoot</code>参数为<code>true</code>。<br>并将<code>Block</code>实例保存在<code>rootBlocks</code>中，就是<code>createApp</code>初始化最后创建的那个。</p><h2 id="unmount"><a class="header-anchor" href="#unmount">#</a>unmount</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootBlocks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">block</span>) =&gt;</span> block.<span class="title function_">teardown</span>())</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>没什么可讲的。<br>使用<code>block</code>实例的<code>teardown</code>方法卸载。</p><h1 id="block-ts"><a class="header-anchor" href="#block-ts">#</a>block.ts</h1><p>只能说，在<code>app.ts</code>中的<code>createApp.mount</code>中会用到。<br>在某些指令中也会用到。</p><h2 id="block类的属性"><a class="header-anchor" href="#block类的属性">#</a><code>Block</code>类的属性</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="title class_">Element</span> | <span class="title class_">DocumentFragment</span> <span class="comment">// 一个dom节点，也是模板。</span></span><br><span class="line">  <span class="attr">ctx</span>: <span class="title class_">Context</span> <span class="comment">// ctx对象</span></span><br><span class="line">  key?: <span class="built_in">any</span> <span class="comment">// 不清楚</span></span><br><span class="line">  parentCtx?: <span class="title class_">Context</span> <span class="comment">// ctx对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">isFragment</span>: <span class="built_in">boolean</span> <span class="comment">// 是否使用template模板</span></span><br><span class="line">  start?: <span class="title class_">Text</span> <span class="comment">// 在 insert()中初始化了。</span></span><br><span class="line">  end?: <span class="title class_">Text</span> <span class="comment">// 在 insert() 中初始化了。</span></span><br></pre></td></tr></table></figure><h2 id="block类的初始化"><a class="header-anchor" href="#block类的初始化">#</a><code>Block</code>类的初始化</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">template: Element, parentCtx: Context, isRoot = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isFragment</span> = template <span class="keyword">instanceof</span> <span class="title class_">HTMLTemplateElement</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRoot) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">template</span> = template</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">isFragment</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">template</span> = (template <span class="keyword">as</span> <span class="title class_">HTMLTemplateElement</span>).<span class="property">content</span>.<span class="title function_">cloneNode</span>(</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      ) <span class="keyword">as</span> <span class="title class_">DocumentFragment</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">template</span> = template.<span class="title function_">cloneNode</span>(<span class="literal">true</span>) <span class="keyword">as</span> <span class="title class_">Element</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRoot) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span> = parentCtx</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// create child context</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parentCtx</span> = parentCtx</span><br><span class="line">      parentCtx.<span class="property">blocks</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span> = <span class="title function_">createContext</span>(parentCtx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">walk</span>(<span class="variable language_">this</span>.<span class="property">template</span>, <span class="variable language_">this</span>.<span class="property">ctx</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先判断<code>template</code>是否为<code>template</code>模板，结果存放到<code>this.isFragment</code>中。</p><p>然后处理<code>this.template</code>。<br>如果<code>isRoot</code>为真，<code>this.template = template</code>。<br>如果<code>this.isFragment</code>为真，将<code>template.content</code>复制一份放到<code>this.template</code>中。<br>否则，，将<code>template</code>复制一份放到<code>this.template</code>中。</p><p>接下来处理<code>this.ctx</code><br>如果<code>isRoot</code>为真，<code>this.ctx = parentCtx</code>。<br>否则，将<code>parentCtx</code>存到<code>this.parentCtx</code>中，然后将block实例存到<code>parentCtx</code>的<code>blocks</code>中，然后重新创建一个<code>ctx</code>对象。</p><p>最后使用<code>walk.ts</code>的<code>walk</code>，处理模板中所有需要响应式的地方。</p><h1 id="walk-ts"><a class="header-anchor" href="#walk-ts">#</a>walk.ts</h1><p>递归处理所有dom节点。<br>首先会检查节点的<code>nodeType</code>。</p><h2 id="nodetype-1"><a class="header-anchor" href="#nodetype-1">#</a>nodeType==1</h2><p>这代表节点为<code>html</code>元素。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Element</span></span><br><span class="line">    <span class="keyword">const</span> el = node <span class="keyword">as</span> <span class="title class_">Element</span></span><br><span class="line">    <span class="keyword">if</span> (el.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-pre&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">checkAttr</span>(el, <span class="string">&#x27;v-cloak&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">exp</span>: <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// v-if</span></span><br><span class="line">    <span class="keyword">if</span> ((exp = <span class="title function_">checkAttr</span>(el, <span class="string">&#x27;v-if&#x27;</span>))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">_if</span>(el, exp, ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v-for</span></span><br><span class="line">    <span class="keyword">if</span> ((exp = <span class="title function_">checkAttr</span>(el, <span class="string">&#x27;v-for&#x27;</span>))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">_for</span>(el, exp, ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v-scope</span></span><br><span class="line">    <span class="keyword">if</span> ((exp = <span class="title function_">checkAttr</span>(el, <span class="string">&#x27;v-scope&#x27;</span>)) || exp === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> scope = exp ? evaluate(ctx.<span class="property">scope</span>, exp) : &#123;&#125;</span><br><span class="line">      ctx = <span class="title function_">createScopedContext</span>(ctx, scope)</span><br><span class="line">      <span class="keyword">if</span> (scope.<span class="property">$template</span>) &#123;</span><br><span class="line">        <span class="title function_">resolveTemplate</span>(el, scope.<span class="property">$template</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v-once</span></span><br><span class="line">    <span class="keyword">const</span> hasVOnce = <span class="title function_">checkAttr</span>(el, <span class="string">&#x27;v-once&#x27;</span>) != <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (hasVOnce) &#123;</span><br><span class="line">      inOnce = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ref</span></span><br><span class="line">    <span class="keyword">if</span> ((exp = <span class="title function_">checkAttr</span>(el, <span class="string">&#x27;ref&#x27;</span>))) &#123;</span><br><span class="line">      <span class="title function_">applyDirective</span>(el, ref, <span class="string">`&quot;<span class="subst">$&#123;exp&#125;</span>&quot;`</span>, ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process children first before self attrs</span></span><br><span class="line">    <span class="title function_">walkChildren</span>(el, ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other directives</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">deferred</span>: [<span class="built_in">string</span>, <span class="built_in">string</span>][] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> &#123; name, value &#125; <span class="keyword">of</span> [...el.<span class="property">attributes</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirRE.<span class="title function_">test</span>(name) &amp;&amp; name !== <span class="string">&#x27;v-cloak&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&#x27;v-model&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// defer v-model since it relies on :value bindings to be processed</span></span><br><span class="line">          <span class="comment">// first, but also before v-on listeners (#73)</span></span><br><span class="line">          deferred.<span class="title function_">unshift</span>([name, value])</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name[<span class="number">0</span>] === <span class="string">&#x27;@&#x27;</span> || <span class="regexp">/^v-on\b/</span>.<span class="title function_">test</span>(name)) &#123;</span><br><span class="line">          deferred.<span class="title function_">push</span>([name, value])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">processDirective</span>(el, name, value, ctx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [name, value] <span class="keyword">of</span> deferred) &#123;</span><br><span class="line">      <span class="title function_">processDirective</span>(el, name, value, ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasVOnce) &#123;</span><br><span class="line">      inOnce = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果节点有属性<code>v-pre</code>，中断。</p><p>如果有<code>v-cloak</code>属性，清除该属性。</p><p>接下来处理<code>v-if</code>和<code>v-for</code>。并返回<code>el</code>的下一个dom节点。</p><p>然后是<code>v-scope</code>。<br>如果<code>v-scope</code>有属性值，在这里处理。<br>如果<code>ctx.scope</code>使用了<code>template</code>模板，在这里处理。</p><p>接下来处理<code>v-once</code>。</p><p>然后调用<code>walkChildren</code>，递归式处理所有dom节点。</p><p>然后处理自定义的指令。</p><h2 id="nodetype-3"><a class="header-anchor" href="#nodetype-3">#</a>nodeType==3</h2><p>这代表为文本节点。</p><p>还记得<code>ctx</code>中定义了分隔符？并且存了一个用于分隔符处理的正则？<br>就在这里用上了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// Text</span></span><br><span class="line">    <span class="keyword">const</span> data = (node <span class="keyword">as</span> <span class="title class_">Text</span>).<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="title function_">includes</span>(ctx.<span class="property">delimiters</span>[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="attr">segments</span>: <span class="built_in">string</span>[] = []</span><br><span class="line">      <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> match</span><br><span class="line">      <span class="keyword">while</span> ((match = ctx.<span class="property">delimitersRE</span>.<span class="title function_">exec</span>(data))) &#123;</span><br><span class="line">        <span class="keyword">const</span> leading = data.<span class="title function_">slice</span>(lastIndex, match.<span class="property">index</span>)</span><br><span class="line">        <span class="keyword">if</span> (leading) segments.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(leading))</span><br><span class="line">        segments.<span class="title function_">push</span>(<span class="string">`$s(<span class="subst">$&#123;match[<span class="number">1</span>]&#125;</span>)`</span>)</span><br><span class="line">        lastIndex = match.<span class="property">index</span> + match[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lastIndex &lt; data.<span class="property">length</span>) &#123;</span><br><span class="line">        segments.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data.<span class="title function_">slice</span>(lastIndex)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">applyDirective</span>(node, text, segments.<span class="title function_">join</span>(<span class="string">&#x27;+&#x27;</span>), ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>虽然没有太看懂。。</p><h2 id="nodetype-11"><a class="header-anchor" href="#nodetype-11">#</a>nodeType==11</h2><p>这代表节点是template标签节点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">11</span>) &#123;</span><br><span class="line">    <span class="title function_">walkChildren</span>(node <span class="keyword">as</span> <span class="title class_">DocumentFragment</span>, ctx)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>直接使用<code>walkChildren</code>进行递归遍历。</p><h1 id="context-ts"><a class="header-anchor" href="#context-ts">#</a>context.ts</h1><p>用于<code>ctx</code>对象相关，包括创建之类的。</p><h2 id="createcontext"><a class="header-anchor" href="#createcontext">#</a>createContext</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createContext = (parent?: <span class="title class_">Context</span>): <span class="function"><span class="params">Context</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">ctx</span>: <span class="title class_">Context</span> = &#123;</span><br><span class="line">    <span class="attr">delimiters</span>: [<span class="string">&#x27;&#123;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#125;&#x27;</span>],</span><br><span class="line">    <span class="attr">delimitersRE</span>: <span class="regexp">/\&#123;\&#123;([^]+?)\&#125;\&#125;/g</span>,</span><br><span class="line">    ...parent,</span><br><span class="line">    <span class="attr">scope</span>: parent ? parent.<span class="property">scope</span> : <span class="title function_">reactive</span>(&#123;&#125;),</span><br><span class="line">    <span class="attr">dirs</span>: parent ? parent.<span class="property">dirs</span> : &#123;&#125;,</span><br><span class="line">    <span class="attr">effects</span>: [],</span><br><span class="line">    <span class="attr">blocks</span>: [],</span><br><span class="line">    <span class="attr">cleanups</span>: [],</span><br><span class="line">    <span class="attr">effect</span>: <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inOnce) &#123;</span><br><span class="line">        <span class="title function_">queueJob</span>(fn)</span><br><span class="line">        <span class="keyword">return</span> fn <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">e</span>: <span class="title class_">ReactiveEffectRunner</span> = <span class="title function_">rawEffect</span>(fn, &#123;</span><br><span class="line">        <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> <span class="title function_">queueJob</span>(e)</span><br><span class="line">      &#125;)</span><br><span class="line">      ctx.<span class="property">effects</span>.<span class="title function_">push</span>(e)</span><br><span class="line">      <span class="keyword">return</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctx</code>对象的根源。<br>在<code>app.ts</code>中，最开始初始化一个空的<code>ctx</code>对象，并把<code>initialData</code>存到<code>ctx.scope</code>中。<br>可以明显看到<code>effect</code>，即需要触发的响应式函数所在。<br><code>rawEffect</code>从<code>@vue/reactivity</code>引入。</p><h2 id="createscopedcontext"><a class="header-anchor" href="#createscopedcontext">#</a>createScopedContext</h2><p>在遍历到有<code>v-scope</code>属性的节点时会调用。<br>毕竟<code>v-scope</code>是有属性值需要处理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createScopedContext = (<span class="attr">ctx</span>: <span class="title class_">Context</span>, data = &#123;&#125;): <span class="function"><span class="params">Context</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> parentScope = ctx.<span class="property">scope</span></span><br><span class="line">  <span class="keyword">const</span> mergedScope = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentScope)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(mergedScope, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(data))</span><br><span class="line">  mergedScope.<span class="property">$refs</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentScope.<span class="property">$refs</span>)</span><br><span class="line">  <span class="keyword">const</span> reactiveProxy = <span class="title function_">reactive</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Proxy</span>(mergedScope, &#123;</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">target, key, val, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// when setting a property that doesn&#x27;t exist on current scope,</span></span><br><span class="line">        <span class="comment">// do not create it on the current scope and fallback to parent scope.</span></span><br><span class="line">        <span class="keyword">if</span> (receiver === reactiveProxy &amp;&amp; !target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(parentScope, key, val)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, val, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bindContextMethods</span>(reactiveProxy)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...ctx,</span><br><span class="line">    <span class="attr">scope</span>: reactiveProxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接将原<code>ctx</code>对象复制了一份，与<code>v-scope</code>属性值合并。<br>然后重新<code>Proxy</code>。<br>最后使用<code>bindContextMethods</code>进行了函数绑定。</p><h2 id="bindcontextmethods"><a class="header-anchor" href="#bindcontextmethods">#</a>bindContextMethods</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">bindContextMethods</span> = (<span class="params">scope: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(scope)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> scope[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      scope[key] = scope[key].<span class="title function_">bind</span>(scope)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新进行函数绑定。</p><h1 id="其他"><a class="header-anchor" href="#其他">#</a>其他</h1><h2 id="eval-ts"><a class="header-anchor" href="#eval-ts">#</a>eval.ts</h2><p>进行属性值表达式处理。</p><h2 id="scheduler-ts"><a class="header-anchor" href="#scheduler-ts">#</a>scheduler.ts</h2><p><code>nextTick</code>，用于响应式处理延迟的。<br><code>queueJob</code>，任务队列。好像用到了<code>ctx</code>的<code>efftct</code>上？<br><code>flushJobs</code>，运行任务队列。</p><h2 id="utils-ts"><a class="header-anchor" href="#utils-ts">#</a>utils.ts</h2><p><code>checkAttr</code>，获得属性值，并清除属性。<br><code>listen</code>，事件绑定？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;petite-vue-调用流程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#petite-vue-调用流程&quot;&gt;#&lt;/a&gt;petite-vue 调用流程&lt;/h1&gt;
&lt;p&gt;目录结构&lt;/p&gt;
&lt;figure class=&quot;highlight pow</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="petite-vue" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/petite-vue/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="http://localhost:5000/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="petite-vue" scheme="http://localhost:5000/tags/petite-vue/"/>
    
  </entry>
  
  <entry>
    <title>petite-vue学习记录1</title>
    <link href="http://localhost:5000/2022/12/13/petite-vue-learn-1/"/>
    <id>http://localhost:5000/2022/12/13/petite-vue-learn-1/</id>
    <published>2022-12-13T02:52:17.000Z</published>
    <updated>2022-12-13T16:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起源"><a class="header-anchor" href="#起源">#</a>起源</h1><p>摸鱼中。摸到了<code>petite-vue</code>。</p><h1 id="总览"><a class="header-anchor" href="#总览">#</a>总览</h1><p>也就<a href="https://github.com/vuejs/petite-vue">petite-vue github</a>了。<br>并没有找到文档什么的。<br>或许有csdn或者简书之类的blog写点东西？</p><h1 id="1-引入"><a class="header-anchor" href="#1-引入">#</a>1. 引入</h1><p>直接cdn引入，或者script标签引入代码。<br>好像vite有个社区模板？<br>并没有见过vite这类前端构建工具使用<code>petite-vue</code>。</p><h1 id="2-引入了什么？"><a class="header-anchor" href="#2-引入了什么？">#</a>2. 引入了什么？</h1><p>假设使用如下方式引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/petite-vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会产生一个<code>PetiteVue</code>变量。<br>之下有<code>createApp</code>，<code>nextTick</code>，<code>reactive</code>3个属性。<br>然后还会默认运行一段代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="variable language_">document</span>.<span class="property">currentScript</span></span><br><span class="line"><span class="keyword">if</span> (s &amp;&amp; s.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;init&#x27;</span>)) &#123;</span><br><span class="line">  <span class="title function_">createApp</span>().<span class="title function_">mount</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即引入<code>PetiteVue</code>时，标签加了<code>init</code>属性会将<code>createApp</code>挂载在全局上。</p><h1 id="3-createapp"><a class="header-anchor" href="#3-createapp">#</a>3. createApp</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createApp = <span class="keyword">function</span>(<span class="params">initialData</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="title function_">directive</span>(<span class="params">name, def?</span>)&#123;&#125;,</span><br><span class="line"><span class="title function_">mount</span>(<span class="params">el? </span>)&#123;&#125;,</span><br><span class="line"><span class="title function_">unmount</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createApp</code>差不多就是这个结构。<br><code>initialData</code>中就是各种属性和函数，通过<code>@vue/reactivity</code>中的<code>reactive</code>变成响应式的，存放在<code>ctx.scope</code>。<br><code>mount</code>的<code>el</code>是可选参数。如果为空，则默认为全局。在挂载过程中，通过<code>document.querySelector(el)</code>获取根dom节点，然后检查下面有<code>v-scope</code>的dom节点，作为接下来的输入，也就是真正响应式发生作用的范围。</p><p><code>initialData</code>也可以写成<code>vue</code>中<code>data</code>的样式，写成一个返回对象的函数。<br>然后在<code>v-scope</code>的属性值中调用函数，进行初始化。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/petite-vue?module&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">props</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">count</span>: props.<span class="property">initialCount</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">inc</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">count</span>++</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I&#x27;m mounted!`</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Counter</span></span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-scope</span>=<span class="string">&quot;Counter(&#123; initialCount: 1 &#125;)&quot;</span> @<span class="attr">vue:mounted</span>=<span class="string">&quot;mounted&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-scope</span>=<span class="string">&quot;Counter(&#123; initialCount: 2 &#125;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-指令"><a class="header-anchor" href="#4-指令">#</a>4. 指令</h1><p>指令列表</p><ol><li>v-bind</li><li>v-effect</li><li>v-for</li><li>v-html</li><li>v-if v-else v-else-if</li><li>v-model</li><li>v-on</li><li>v-ref</li><li>v-show</li><li>v-text</li></ol><h2 id="v-effect"><a class="header-anchor" href="#v-effect">#</a>v-effect</h2><p>行内执行响应式代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-scope</span>=<span class="string">&quot;&#123; count: 0 &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-effect</span>=<span class="string">&quot;$el.textContent = count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="5-其他"><a class="header-anchor" href="#5-其他">#</a>5. 其他</h1><h2 id="v-scope"><a class="header-anchor" href="#v-scope">#</a>v-scope</h2><p>它是根。<code>petite-vue</code>以它所在dom节点作为根。<br>后面的属性值应返回一个对象。<br>和根的<code>ctx.scope</code>合并作为根下的响应式对象。</p><h2 id="vue-mounted-vue-unmounted"><a class="header-anchor" href="#vue-mounted-vue-unmounted">#</a>@vue:mounted @vue:unmounted</h2><p>在app挂载和卸载是执行的行内语句。</p><h2 id="定制指令"><a class="header-anchor" href="#定制指令">#</a>定制指令</h2><p>我也不是很懂。<br>所以复制粘贴大法。<br>来自<a href="https://github.com/vuejs/petite-vue">petite-vue github</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myDirective</span> = (<span class="params">ctx</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// the element the directive is on</span></span><br><span class="line">  ctx.<span class="property">el</span></span><br><span class="line">  <span class="comment">// the raw value expression</span></span><br><span class="line">  <span class="comment">// e.g. v-my-dir=&quot;x&quot; then this would be &quot;x&quot;</span></span><br><span class="line">  ctx.<span class="property">exp</span></span><br><span class="line">  <span class="comment">// v-my-dir:foo -&gt; &quot;foo&quot;</span></span><br><span class="line">  ctx.<span class="property">arg</span></span><br><span class="line">  <span class="comment">// v-my-dir.mod -&gt; &#123; mod: true &#125;</span></span><br><span class="line">  ctx.<span class="property">modifiers</span></span><br><span class="line">  <span class="comment">// evaluate the expression and get its value</span></span><br><span class="line">  ctx.<span class="title function_">get</span>()</span><br><span class="line">  <span class="comment">// evaluate arbitrary expression in current scope</span></span><br><span class="line">  ctx.<span class="title function_">get</span>(<span class="string">`<span class="subst">$&#123;ctx.exp&#125;</span> + 10`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// run reactive effect</span></span><br><span class="line">  ctx.<span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this will re-run every time the get() value changes</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="title function_">get</span>())</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// cleanup if the element is unmounted</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the directive</span></span><br><span class="line"><span class="title function_">createApp</span>().<span class="title function_">directive</span>(<span class="string">&#x27;my-dir&#x27;</span>, myDirective).<span class="title function_">mount</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起源&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起源&quot;&gt;#&lt;/a&gt;起源&lt;/h1&gt;
&lt;p&gt;摸鱼中。摸到了&lt;code&gt;petite-vue&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;总览&quot;&gt;&lt;a class=&quot;header-anchor&quot; hre</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="petite-vue" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/petite-vue/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="http://localhost:5000/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="petite-vue" scheme="http://localhost:5000/tags/petite-vue/"/>
    
  </entry>
  
  <entry>
    <title>flask记录-1</title>
    <link href="http://localhost:5000/2022/12/12/flask-self-1/"/>
    <id>http://localhost:5000/2022/12/12/flask-self-1/</id>
    <published>2022-12-12T04:40:41.000Z</published>
    <updated>2022-12-12T05:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源点"><a class="header-anchor" href="#源点">#</a>源点</h1><p>提高前端项目的体量，需要一个后端支撑。所以选了flask？<br>其实是根据项目面对人群进行的选择。<br>标注面对ml人群，他们很有可能直接一发anaconda，然后里面就默认安装flask。<br>对于那些需要做保密项目，安装开发环境艰难，开发环境简陋的比较友好？<br>毕竟在linux平台安装python的最简单方案就是anaconda。<br>在此记录一下flask项目中的一些bug。<br>毕竟bug数量已经是函数数量的好几倍了。</p><h1 id="启动"><a class="header-anchor" href="#启动">#</a>启动</h1><p>在flask文档中flask的启动是，首先设定一个flask相关的临时环境变量，然后通过<code>flask run</code>命令启动。<br>如果文件名是<code>app.py</code>等几种，也可以直接<code>flask run</code>。</p><p>我就直接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app = create_app()</span><br><span class="line">app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>其中<code>debug=True</code>开启了debug模式，如果修改文件，则自动重启flask服务。<br>这种方法适用于开发模式。<br>当然，我也没想着能够部署。</p><h1 id="cors"><a class="header-anchor" href="#cors">#</a>cors</h1><p>cors非常轻松。<br>直接安装<code>flask_cors</code>包。<br>然后在<code>config.py</code>中设置对应配置，然后导入即可。<br>然后就可以轻松在前端进行<code>ajax</code>通信了。</p><h1 id="json-web-token"><a class="header-anchor" href="#json-web-token">#</a>json web token</h1><p>可以看看<a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a><br>这里使用了<code>pyjwt</code>。<br>jwt分为三段。</p><blockquote><p>第一段是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, # 加密算法</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span> # 代表token类型是json web token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行base64转换。这是明文。</p></blockquote><blockquote><p>第二段是一些json记录。<br>其中一些键是保留字段。<br>在pyjwt中实现了一下<br><code>exp</code> (Expiration Time) Claim 到期时间<br><code>nbf</code> (Not Before Time) Claim 起始时间，在这之前的请求不予处理<br><code>iss</code> (Issuer) Claim 发行人<br><code>aud</code> (Audience) Claim 受众，我也不清楚这是什么<br><code>iat</code> (Issued At) Claim 发行时间<br>总之，我用了<code>iat</code>和<code>exp</code>，限制了token的生效时间。<br>然后自定义了一个<code>actor</code>字段描述用户角色。<br>最后把这段进行base64转换。这是明文。</p></blockquote><blockquote><p>第三段是密文<br>就是根据生成的密码，对第一段和第二段进行加密，防止用户修改第一段和第二段（第一段和第二段是明文）。<br>如果用户修改第一段和第二段，就可以通过密文和明文比对发现。<br>加密算法在第一段中声明了<br>或许还会用到hmac。hmac和hashlib都是Python的默认库。</p></blockquote><p>jwt加密密码是每次启动flask时清空，调用时如果为空使用<code>secret</code>包生成一份。</p><h1 id="auth"><a class="header-anchor" href="#auth">#</a>auth</h1><p>auth用户认证。包括用户身份认证，注册登录注销等。</p><p>首先使用了<code>flask_auth</code>包。<br>使用了里面的<code>HTTPTokenAuth</code><br>里面的认证机制有两个。</p><ol><li>authenticate<br>本来是用户名和密码进行验证。<br><code>HTTPTokenAuth</code>对应的则是token能否被验证。这里通过pyjwt进行。<br>对应的函数需要使用<code>@auth.verify_token</code>装饰一下</li><li>authorize<br>是用来验证用户的角色的。访问某些url需要验证一下用户角色。<br>而这个项目的用户角色存放在token中，在解析token时就返回了。<br>总之建议阅读这个<code>authorize</code>的源码。<br>说实话，源码比文档好读。。</li></ol><p>这里注册是密码直接明文放到数据库中了。至于如何加密，在flask文档中有。<br>登录就直接向前端发一个token。至于这个token后端也没有记录。<br>注销功能后端就直接没写。直接让前端删除token吧。反正前端估计也是我写。</p><h1 id="db"><a class="header-anchor" href="#db">#</a>db</h1><p>数据库使用的是python自带的sqlite3。<br>首先在flask文档里把db的句柄（就是sqlite3.connect返回的那个）存到了<code>g</code>对象中。<br>这是有原因的。<br>sqlite3的文件crud权限有同时只能有一个线程的限制。<br>所以文档里最后还有个<code>app.teardown_appcontext</code><br>但是我这里的<code>init_db</code>就直接运行<code>db.py</code>就可以了。。</p><h1 id="db-execute"><a class="header-anchor" href="#db-execute">#</a>db.execute</h1><p>在数据库操作中的bug。。<br>首先，这个<code>db.execute</code>可以进行字符串转换，防止注入（好像是这样的）。<br>然后输入数据时需要<code>()</code>，如果只有一个变量，勿忘在变量后加一个逗号。<br>同时进行多组时可以使用<code>executemany</code>。</p><h1 id="获得参数之后"><a class="header-anchor" href="#获得参数之后">#</a>获得参数之后</h1><p>第一步就是对参数的结构进行认证。<br>或者是确认参数类型？<br>为此直接在<code>utils.py</code>来了一发<code>req_need_key</code>函数。</p><h1 id="其他"><a class="header-anchor" href="#其他">#</a>其他</h1><p>当然还有问题。<br>比如在编写到中途时修改数据库结构。<br>反正直接一发<code>init_db</code>就可以。<br>还有<code>task</code>任务需要时间线限制。还没编写。<br>总之，问题多多。大不了交给前端。<br>反正前端也是在下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源点&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#源点&quot;&gt;#&lt;/a&gt;源点&lt;/h1&gt;
&lt;p&gt;提高前端项目的体量，需要一个后端支撑。所以选了flask？&lt;br&gt;
其实是根据项目面对人群进行的选择。&lt;br&gt;
标注面对ml人群，他们很有可能直接一发a</summary>
      
    
    
    
    <category term="后端" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/flask/"/>
    
    
    <category term="后端" scheme="http://localhost:5000/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-身份认证</title>
    <link href="http://localhost:5000/2022/12/03/auth/"/>
    <id>http://localhost:5000/2022/12/03/auth/</id>
    <published>2022-12-03T14:39:49.000Z</published>
    <updated>2022-12-03T15:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1><p>token，又是前端八股常考且必考。但总是云里雾里。<br>这篇文章里也差不多。<br>没事可以多看看</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 身份验证</a></li><li><a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a></li><li><a href="https://oauth.net/2/">OAuth 2.0</a></li></ul><h1 id="总领"><a class="header-anchor" href="#总领">#</a>总领</h1><p>到底怎么认证一个用户？<br>简答来说，就是在HTTP头部放一段密文，用于验证。<br>至于怎么放，放什么，五花八门。</p><h1 id="在mdn中"><a class="header-anchor" href="#在mdn中">#</a>在MDN中</h1><p>依据文章<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 身份验证</a><br>认证的流程基本就是，客户端请求，服务端通过<code>WWW-Authenticate</code>首部通知如何认证；然后经过认证后，客户端使用<code>Authorization</code>发送认证字段。</p><p>至于认证的方案：</p><ol><li>Basic (查看 RFC 7617，base64 编码凭证。),</li><li>Bearer (查看 RFC 6750，bearer 令牌通过 OAuth 2.0 保护资源),</li><li>Digest (查看 RFC 7616，只有 md5 散列 在 Firefox 中支持，查看 bug 472823 用于 SHA 加密支持),</li><li>HOBA (查看 RFC 7486（草案），HTTP Origin-Bound 认证，基于数字签名),</li><li>Mutual (查看 draft-ietf-httpauth-mutual),</li><li>AWS4-HMAC-SHA256 (查看 AWS docs).</li></ol><p>。。基本就是Basic和Bearer。剩下的我也不知道。。</p><p>Basic最简单了，用&quot;:&quot;将用户名和密码拼接，然后使用base64编码，就完事了。参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization">Authorization</a></p><p>Bearer的可以参见<a href="https://oauth.net/2/">OAuth 2.0</a>。反正我是没怎么看懂。</p><h1 id="cookie"><a class="header-anchor" href="#cookie">#</a>cookie</h1><p>首先cookie是什么样的？<br>在浏览器中的开发者工具中开启网络选项页可以看到，cookie在请求头中是一个字符串，可以格式化成一堆键值对。<br>总之是一个存放数据的地方。<br>在Storage api之前是主要存放数据的地方。</p><p>而在flask中的session变量存放的键值对也会放到cookie中</p><p>当然也可以存放密文用于身份验证。</p><h1 id="token"><a class="header-anchor" href="#token">#</a>token</h1><p>世界上或许有很多种token？或许吧。<br>但我只知道jsonwebtoken。<br>参见<a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a></p><p>jwt分为三部分，头部header，负载payload，签名Signature。<br>header包含两部分，token的类型，加密算法<br>payload包含各种信息。<br>Signature，需要计算。</p><p>首先，头部需要将json转换为字符串，然后经过base64。<br>然后负载也一样。<br>最后签名需要使用加密算法，将头部负载和密码一起放入。</p><p>在python中<br>base64可以用<code>base64</code>库，加密算法可以用<code>hashlib</code>库，hmac算法可以用<code>hmac</code>库。这些库都是默认就有的。<br>在js中<br>base64可以用<code>atob</code>和<code>btoa</code>函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;token，又是前端八股常考且必考。但总是云里雾里。&lt;br&gt;
这篇文章里也差不多。&lt;br&gt;
没事可以多看看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="auth" scheme="http://localhost:5000/tags/auth/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享</title>
    <link href="http://localhost:5000/2022/12/01/cors/"/>
    <id>http://localhost:5000/2022/12/01/cors/</id>
    <published>2022-12-01T05:01:27.000Z</published>
    <updated>2022-12-01T06:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1><p>首先，这篇是从<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS?qs=cors">跨源资源共享（CORS）</a>中弄出来的。<br>说起来，MDN还真是强大呢。<br>跨域资源共享，或称为CORS，是一种浏览器安全机制，需要后端的配合。现在前后端分离的趋势下，加给一种前端的源和后端的源的限制，以达到安全的目的。具体上是，在后端中设置一些访问的限制，主要是访问的源的限制，也有其他的限制；浏览器端中如果发现请求不符合后端服务器的限制，则返回请求失败。</p><h1 id="同源的定义"><a class="header-anchor" href="#同源的定义">#</a>同源的定义</h1><p>如果两个 URL 的 protocol、port (en-US) (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。</p><p>出自<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略</a></p><h1 id="什么情况下需要cors"><a class="header-anchor" href="#什么情况下需要cors">#</a>什么情况下需要CORS</h1><ul><li>前文提到的由 XMLHttpRequest 或 Fetch API 发起的跨源 HTTP 请求。</li><li>Web 字体（CSS 中通过 @font-face 使用跨源字体资源），因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图。</li><li>使用 drawImage() 将图片或视频画面绘制到 canvas。</li><li>来自图像的 CSS 图形 (en-US)。</li></ul><p>出自<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS?qs=cors">跨源资源共享（CORS）</a></p><h1 id="流程"><a class="header-anchor" href="#流程">#</a>流程</h1><ol><li>浏览器通过XHR或者Fetch等方式发起跨域资源请求。</li><li>判断是否为简单请求</li></ol><p>3.1. 如果是简单请求</p><blockquote><p>直接向后端发起请求，通过返回的响应头判断请求是否符合CORS的安全策略</p></blockquote><p>3.2. 如果不是简单请求</p><blockquote><p>先发起预检请求，判断是否符合CORS的安全策略<br>如果符合安全策略，再发送实际的请求</p></blockquote><h1 id="什么是简单请求"><a class="header-anchor" href="#什么是简单请求">#</a>什么是简单请求</h1><p>这实在是一个复杂的问题，估计在面试中把答案说出来，面试官也很少能弄清。<br>前3条还好，后两条比较难遇到。</p><ol><li>使用下列方法之一</li></ol><blockquote><p>GET, HEAD, POST</p></blockquote><ol start="2"><li>除了被用户代理自动设置的首部字段，允许人为设置的字段为Fetch规范定义的对 CORS 安全的首部字段集合：</li></ol><blockquote><p>Accept<br>Accept-Language<br>Content-Language<br>Content-Type（需要注意额外的限制）<br>Range（只允许简单的范围首部值 如 bytes=256- 或 bytes=127-255）</p></blockquote><ol start="3"><li>Content-Type 首部所指定的媒体类型的值仅限于下列三者之一：</li></ol><blockquote><p>text/plain<br>multipart/form-data<br>application/x-www-form-urlencoded</p></blockquote><ol start="4"><li>如果请求是使用 XMLHttpRequest 对象发出的，在返回的 XMLHttpRequest.upload 对象属性上没有注册任何事件监听器；也就是说，给定一个 XMLHttpRequest 实例 xhr，没有调用 xhr.upload.addEventListener()，以监听该上传请求。</li><li>请求中没有使用 ReadableStream 对象。</li></ol><h1 id="需要注意的头部"><a class="header-anchor" href="#需要注意的头部">#</a>需要注意的头部</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Access-Control-Allow-Origin:</span> <span class="string">https://foo.example</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Methods:</span> <span class="string">POST,</span> <span class="string">GET,</span> <span class="string">OPTIONS</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Headers:</span> <span class="string">X-PINGOTHER,</span> <span class="string">Content-Type</span></span><br><span class="line"><span class="attr">Access-Control-Max-Age:</span> <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>。。应该能轻松看懂吧。<br>这是在后端服务器上设置的头部，在CORS请求中的响应头中返回的字段，用于CORS的安全策略。<br>包括设置了允许访问的源，允许访问的方式，请求头中允许设置的头部字段，预检请求可以缓存时间从长短（单位秒）。</p><h1 id="fetch"><a class="header-anchor" href="#fetch">#</a>fetch</h1><p>是的，fetch的访问也会受到cors的限制，与简单请求有一定的相关。可以多注意一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;首先，这篇是从&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS?qs=co</summary>
      
    
    
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="cors" scheme="http://localhost:5000/tags/cors/"/>
    
  </entry>
  
  <entry>
    <title>任务，微任务，事件循环以及js运行时理论篇</title>
    <link href="http://localhost:5000/2022/11/30/js-runtime/"/>
    <id>http://localhost:5000/2022/11/30/js-runtime/</id>
    <published>2022-11-30T07:21:29.000Z</published>
    <updated>2022-11-30T14:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景">#</a>背景</h1><p>宏任务和微任务是前端八股重要一问。<br>答案就是宏任务在微任务之前。<br>但到底是怎么一回事呢？<br>当然可以直接去看<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">In depth: Microtasks and the JavaScript runtime environment</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a><br>我也不过是从中总结而已。</p><h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1><p>在MDN中，在下只找到了一处使用<code>宏任务</code>这个词的地方。<br>就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a>，里面使用括号标注了<code>宏任务</code>这个词。<br>而在英文，以及大部分的中文翻译中，都只是用了<code>task</code>或者<code>任务</code>这个词。</p><h1 id="第一核心问题"><a class="header-anchor" href="#第一核心问题">#</a>第一核心问题</h1><p>第一核心问题，当然是什么是任务和微任务。<br>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a>中有解答。</p><ul><li>任务：一个 任务 就是由执行诸如从头执行一段程序、执行一个事件回调或一个 interval/timeout 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 任务队列（task queue）上被调度。</li><li>微任务：一个 微任务（microtask）就是一个简短的函数，当创建该函数的函数执行之后，并且 只有当 Javascript 调用栈为空，而控制权尚未返还给被 user agent 用来驱动脚本执行环境的事件循环之前，该微任务才会被执行。</li></ul><p>是不是一头雾水？那换一种说法，也是八股常考，如何触发任务和微任务。</p><p>任务触发：</p><ol><li>一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 script 元素中运行代码）。</li><li>触发了一个事件，将其回调函数添加到任务队列时。</li><li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时。</li></ol><p>微任务触发：<br>JavaScript 中的 promises 和 Mutation Observer API 都使用微任务队列去运行它们的回调函数，但当能够推迟工作直到当前事件循环过程完结时，也是可以执行微任务的时机。为了允许第三方库、框架、polyfills 能使用微任务，Window 暴露了 queueMicrotask() 方法，而 Worker 接口则通过 WindowOrWorkerGlobalScope mixin 提供了同名的 queueMicrotask() 方法。</p><blockquote><p>也就是promises、Mutation Observer API和queueMicrotask。</p></blockquote><h1 id="什么是事件循环"><a class="header-anchor" href="#什么是事件循环">#</a>什么是事件循环</h1><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a>有解答。</p><p>每个代理都是由事件循环驱动的，事件循环负责收集事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务，然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</p><p>网页或者 app 的代码和浏览器本身的用户界面程序运行在相同的 线程中，共享相同的 事件循环。该线程就是 主线程，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。</p><p>然后，事件循环会驱动发生在浏览器中与用户交互有关的一切，但在这里，对我们来说更重要的是需要了解它是如何负责调度和执行在其线程中执行的每段代码的。</p><p>有如下三种事件循环：</p><ol><li>Window 事件循环</li></ol><blockquote><p>window 事件循环驱动所有同源的窗口 (though there are further limits to this as described elsewhere in this article XXXX ???).</p></blockquote><ol start="2"><li>Worker 事件循环</li></ol><blockquote><p>worker 事件循环顾名思义就是驱动 worker 的事件循环。这包括了所有种类的 worker：最基本的 web worker 以及 shared worker 和 service worker。Worker 被放在一个或多个独立于“主代码”的代理中。浏览器可能会用单个或多个事件循环来处理给定类型的所有 worker。</p></blockquote><ol start="3"><li>Worklet 事件循环</li></ol><blockquote><p>worklet (en-US) 事件循环用于驱动运行 worklet 的代理。这包含了 Worklet (en-US)、AudioWorklet (en-US) 以及 PaintWorklet (en-US)。</p></blockquote><p>多个同源（译者注：此处同源的源应该不是指同源策略中的源，而是指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等，意味着起源的意思，下一段内容就会对这里进行说明）窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。记住这里的网络术语“window”实际上指的用于运行网页内容的浏览器级容器，包括实际的 window，一个 tab 标签或者一个 frame。</p><p>在特定情况下，同源窗口之间共享事件循环，例如：</p><p>如果一个窗口打开了另一个窗口，它们可能会共享一个事件循环。<br>如果窗口是包含在 iframe 中，则它可能会和包含它的窗口共享一个事件循环。<br>在多进程浏览器中多个窗口碰巧共享了同一个进程。<br>这种特定情况依赖于浏览器的具体实现，各个浏览器可能并不一样。</p><p>总结：<br>事件循环线程就是主线程。至于背地里做的那些事，由浏览器安排。<br>事件循环线程的流程：</p><ol><li>收集事件（包括用户事件以及其他非用户事件等）</li><li>对任务进行排队以便在合适的时候执行回调</li><li>执行所有处于等待中的 JavaScript 任务</li><li>执行所有处于等待中的 JavaScript 微任务</li><li>执行一些必要的渲染和绘制操作</li></ol><h1 id="任务和微任务的先后"><a class="header-anchor" href="#任务和微任务的先后">#</a>任务和微任务的先后</h1><p>。。简单的话，事件循环已经解答了。<br>在一次事件循环中，先执行任务，再执行微任务。<br>至于细节一点。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a>里讲。</p><p>首先，每当一个任务存在，事件循环都会检查该任务是否正把控制权交给其他 JavaScript 代码。如若不然，事件循环就会运行微任务队列中的所有微任务。<br>其次，如果一个微任务通过调用 queueMicrotask(), 向队列中加入了更多的微任务，则那些新加入的微任务 会早于下一个任务运行。这是因为事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。</p><h1 id="最后"><a class="header-anchor" href="#最后">#</a>最后</h1><p>上面说的是真的吗？<br>不过是MDN中讲的罢了。<br>还需要真正用代码来验证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;#&lt;/a&gt;背景&lt;/h1&gt;
&lt;p&gt;宏任务和微任务是前端八股重要一问。&lt;br&gt;
答案就是宏任务在微任务之前。&lt;br&gt;
但到底是怎么一回事呢？&lt;br&gt;
当然可以直接去看&lt;br&gt;
&lt;a hre</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="eventLoop" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/eventLoop/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="eventLoop" scheme="http://localhost:5000/tags/eventLoop/"/>
    
    <category term="js-runtime" scheme="http://localhost:5000/tags/js-runtime/"/>
    
    <category term="microtask" scheme="http://localhost:5000/tags/microtask/"/>
    
  </entry>
  
  <entry>
    <title>flask-tutorial</title>
    <link href="http://localhost:5000/2022/11/29/flask-tutorial/"/>
    <id>http://localhost:5000/2022/11/29/flask-tutorial/</id>
    <published>2022-11-29T05:14:23.000Z</published>
    <updated>2022-11-30T07:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a class="header-anchor" href="#起因">#</a>起因</h1><p>最近简单看了flask的文档。<br>然后把里面<a href="https://dormousehole.readthedocs.io/en/latest/tutorial/index.html">教程</a>的那一章敲了一遍。<br>敲完的代码放到了<a href="https://github.com/el-psy/flask-tutorial">这里</a>。<br>但是只是浮光掠影，对于flask还是不甚了解。<br>所以准备将这些代码中不懂的部分简单总结一下。虽然总结之后还是不懂，但总是方便查找了。</p><h1 id="概括"><a class="header-anchor" href="#概括">#</a>概括</h1><p>flask大概就是通过装饰器装饰函数，使用url调用该函数，返回值可以通过模板的方式合成html页面。<br>至于项目。<br>可以分为4个部分：</p><ul><li><code>__init__.py</code>主体部分。包括配置引入。</li><li><code>auth.py</code>认证部分。包括登录注册注销，以及一个装饰器，用于那些需要登录才能访问的url。</li><li><code>db.py</code>数据部分。包括连接数据库，初始化数据库，关闭数据库连接之类的。</li><li><code>blog.py</code>blog部分。主要功能所在。包括增加修改删除功能。</li></ul><h1 id="init"><a class="header-anchor" href="#init">#</a>__init__</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>(<span class="params">test_config=<span class="literal">None</span></span>):</span><br><span class="line">app = Flask(__name__, instance_relative_config = <span class="literal">True</span>)</span><br><span class="line">app.config.from_mapping(</span><br><span class="line">SECRET_KEY = <span class="string">&#x27;dev&#x27;</span>,</span><br><span class="line">DATABASE = os.path.join(app.instance_path, <span class="string">&#x27;flask.sqlite&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> test_config <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">app.config.from_pyfile(<span class="string">&#x27;config.py&#x27;</span>, silent = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">app.config.from_mapping(test_config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">os.makedirs(app.instance_path)</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> db</span><br><span class="line">db.init_app(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> auth</span><br><span class="line">app.register_blueprint(auth.bp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> blog</span><br><span class="line">app.register_blueprint(blog.bp)</span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/&#x27;</span>, endpoint=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><ol><li><code>instance_relative_config</code></li></ol><blockquote><p>配置文件路径相关。默认是“相对于应用的根目录”，这个值为<code>True</code>的时候为“相对于实例文件夹”。</p></blockquote><ol start="2"><li>SECRET_KEY</li></ol><blockquote><p>说是秘钥，但也没有明显发现其他代码哪里用到了。或许是<code>auth.py</code>中的<code>generate_password_hash</code>之类的？</p></blockquote><ol start="3"><li>DATABASE</li></ol><blockquote><p>数据库文件路径。在<code>db.py</code>中使用。</p></blockquote><ol start="4"><li>app.add_url_rule</li></ol><blockquote><p>完全看不懂</p></blockquote><h1 id="db"><a class="header-anchor" href="#db">#</a>db</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app, g</span><br><span class="line"><span class="keyword">from</span> flask.cli <span class="keyword">import</span> with_appcontext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_db</span>():</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;db&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">g.db = sqlite3.connect(</span><br><span class="line">current_app.config[<span class="string">&#x27;DATABASE&#x27;</span>],</span><br><span class="line">detect_types=sqlite3.PARSE_DECLTYPES</span><br><span class="line">)</span><br><span class="line">g.db.row_factory = sqlite3.Row</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> g.db</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close_db</span>(<span class="params">e=<span class="literal">None</span></span>):</span><br><span class="line">db = g.pop(<span class="string">&#x27;db&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> db <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db</span>():</span><br><span class="line">db = get_db()</span><br><span class="line"><span class="keyword">with</span> current_app.open_resource(<span class="string">&#x27;schema.sql&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">db.executescript(f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command(<span class="params"><span class="string">&#x27;init-db&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@with_appcontext</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db_command</span>():</span><br><span class="line">init_db()</span><br><span class="line">click.echo(<span class="string">&#x27;Initialized the database.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_app</span>(<span class="params">app</span>):</span><br><span class="line">app.teardown_appcontext(close_db)</span><br><span class="line">app.cli.add_command(init_db_command)</span><br></pre></td></tr></table></figure><ol><li>current_app</li></ol><blockquote><p>类型是LocalProxy<br>像全局变量一样工作，但只能在处理请求期间且在处理它的线程中访问<br>返回的栈顶元素不是应用上下文，而是flask的应用实例对象<br>Flask 应用对象app具有config的属性，这些属性对于在视图或者在命令调试中访问很方便。但是现在项目的模块导入app 实例会容易出现循环导入的问题<br>Flask 通过应用情景解决了这个问题，不是直接引用一个app，而是使用current_app 代理，该代理指向处理当前活动的应用；<br>至于到底是什么我也不知道。。。感谢百度。</p></blockquote><ol start="2"><li>g</li></ol><blockquote><p>flask的全局变量</p></blockquote><ol start="3"><li>g.db.row_factory = sqlite3.Row</li></ol><blockquote><p>这样查询会返回 Row 对象，而不是字典。 Row 对象是 namedtuple ，因 此既可以通过索引访问也以通过键访问。</p></blockquote><ol start="4"><li>current_app.open_resource</li></ol><blockquote><p>打开文件。相对于应用的相对路径。在<code>__init__.py</code>中设置过。</p></blockquote><ol start="5"><li>with_appcontext</li></ol><blockquote><p>包装回调，以确保它能够与脚本的应用程序上下文一起执行。如果回调直接注册到app.cli对象，则默认情况下，除非禁用此函数，否则将使用此函数包装回调。</p></blockquote><ol start="6"><li>app.teardown_appcontext</li></ol><blockquote><p>注册应用程序上下文结束时要调用的函数。当弹出请求上下文时，通常也会调用这些函数。</p></blockquote><ol start="7"><li>init_app</li></ol><blockquote><p>最终注册的函数。</p></blockquote><h1 id="auth"><a class="header-anchor" href="#auth">#</a>auth</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp = Blueprint(<span class="string">&#x27;auth&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/auth&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>所谓的蓝图</li></ol><blockquote><p>name=“auth” 蓝图的名称。将在每个端点名称前加上前缀。<br>import_name=__name__ 蓝图包的名称，通常为__name__。这有助于定位蓝图的root_path。<br>url_prefix=&quot;/auth&quot; 一个路径，用于在蓝图的所有URL前加上前缀，使其与应用程序的其他路径不同。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/register&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span> :</span><br><span class="line">username = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">db = get_db()</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">error = <span class="string">&#x27;Username is required.&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> password:</span><br><span class="line">error = <span class="string">&#x27;Password is required.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;insert into user (username, password) values (?, ?)&#x27;</span>,</span><br><span class="line">(username, generate_password_hash(password)),</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">except</span> db.IntegrityError:</span><br><span class="line">error = <span class="string">f&quot;User <span class="subst">&#123;username&#125;</span> is already registered.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.login&#x27;</span>))</span><br><span class="line">flash(error)</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;auth/register.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>request</li></ol><blockquote><p>请求体。试试文档api中的<code>Incoming Request Data</code>？</p></blockquote><ol start="2"><li>db.execute</li></ol><blockquote><p>会进行字符串转换的。。</p></blockquote><ol start="3"><li>generate_password_hash</li></ol><blockquote><p>加密</p></blockquote><ol start="4"><li>flash</li></ol><blockquote><p>所谓的error提示。其实会在模板中会有体现。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">username = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">db = get_db()</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line">user = db.execute(</span><br><span class="line"><span class="string">&#x27;select * from user where username = ?&#x27;</span>,</span><br><span class="line">(username,)</span><br><span class="line">).fetchone()</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">error = <span class="string">&#x27;Incorrect username.&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> check_password_hash(user[<span class="string">&#x27;password&#x27;</span>], password):</span><br><span class="line">error = <span class="string">&#x27;Incorrect password.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">session.clear()</span><br><span class="line">session[<span class="string">&#x27;user_id&#x27;</span>] = user[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br><span class="line"></span><br><span class="line">flash(error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;auth/login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>check_password_hash</li></ol><blockquote><p>验证加密。</p></blockquote><ol start="2"><li>session</li></ol><blockquote><p>session和cookie的作用有点类似，都是为了存储用户相关的信息的，区别在于 session 是保存在服务器端的，用 session_id 来标识用户。而 cookie 是保存在客户端，session 的出现，是为了解决 cookie 存储数据不安全的问题的。<br>flask中的session机制是：把敏感数据经过加密后放入session中，然后再把session存放到cookie中，下次请求的时候，再从浏览器发送过来的cookie中读取session，然后再从session中读取敏感数据，并进行解密，获取最终的用户数据。<br>使用session需要设置SECRET_KEY</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.before_app_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_logged_in_user</span>():</span><br><span class="line">user_id = session.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> user_id <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">g.user = <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">g.user = get_db().execute(</span><br><span class="line"><span class="string">&#x27;select * from user where id = ?&#x27;</span>,</span><br><span class="line">(user_id,)</span><br><span class="line">).fetchone()</span><br></pre></td></tr></table></figure><ol><li>before_app_request</li></ol><blockquote><p>这样的函数在每次请求之前执行，即使在蓝图之外。</p></blockquote><ol start="2"><li>g</li></ol><blockquote><p>别问我为什么需要将user数据设置在g里。我也不知道。。。<br>2.1. 生命周期<br>请求过来创建，请求结束销毁；<br>仅适用于单次请求，g的生命周期即一个请求的生命周期<br>注：和session不同，session是多个请求都可以使用的<br>2.2. g是什么<br>g相当于单次请求中的“全局变量”，能在单词请求中调用，但是和其他请求是互相隔离的<br>可以参考上下文管理部分，g的创建与销毁流程理解<br>2.3. g能做什么<br>可以在单次请求中定义一些值和操作，随着本次请求结束而销毁；<br>如，权限管理</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/logout&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>():</span><br><span class="line">session.clear()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br></pre></td></tr></table></figure><ol><li>session.clear()</li></ol><blockquote><p>清空session。cookie也随之清空。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">view</span>):</span><br><span class="line"><span class="meta">@functools.wraps(<span class="params">view</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapped_view</span>(<span class="params">**kwargs</span>):</span><br><span class="line"><span class="keyword">if</span> g.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.login&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> view(**kwargs)</span><br><span class="line"><span class="keyword">return</span> wrapped_view</span><br></pre></td></tr></table></figure><ol><li>functools.wraps</li></ol><blockquote><p>首先这是一个装饰器，用于需要经过验证才能访问的url的。<br>标准库 functools 中的 wrap 函数用于包装函数, 不改变原有函数的功能, 仅改变原有函数的一些属性, 例如 __name__, __doc__, __annotations__ 等属性<br>我也不知道在这里使用到底有什么用。。</p></blockquote><h1 id="blog"><a class="header-anchor" href="#blog">#</a>blog</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> ( Blueprint, flash, g, redirect, render_template, request, url_for )</span><br><span class="line"><span class="keyword">from</span> werkzeug.exceptions <span class="keyword">import</span> abort</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flaskr.auth <span class="keyword">import</span> login_required</span><br><span class="line"><span class="keyword">from</span> flaskr.db <span class="keyword">import</span> get_db</span><br><span class="line"></span><br><span class="line">bp = Blueprint(<span class="string">&#x27;blog&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">db = get_db()</span><br><span class="line">posts = db.execute(</span><br><span class="line"><span class="string">&#x27;select p.id, title, body, created, author_id, username from post p join user u on p.author_id = u.id order by created desc&#x27;</span></span><br><span class="line">).fetchall()</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;blog/index.html&#x27;</span>, posts = posts)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/create&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>():</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">title = request.form[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">body = request.form[<span class="string">&#x27;body&#x27;</span>]</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> title:</span><br><span class="line">error = <span class="string">&#x27;Title is required.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">flash(error)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">db = get_db()</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;insert into post (title, body, author_id) values (?,?,?)&#x27;</span>,</span><br><span class="line">(title, body, g.user[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;blog.index&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;blog/create.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_post</span>(<span class="params"><span class="built_in">id</span>, check_author = <span class="literal">True</span></span>):</span><br><span class="line">post = get_db().execute(</span><br><span class="line"><span class="string">&#x27;select p.id, title, body, created, author_id, username from post p join user u on p.author_id = u.id where p.id = ?&#x27;</span>,</span><br><span class="line">(<span class="built_in">id</span>,)</span><br><span class="line">).fetchone()</span><br><span class="line"><span class="keyword">if</span> post <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">abort(<span class="number">404</span>, <span class="string">f&#x27;Post id <span class="subst">&#123;<span class="built_in">id</span>&#125;</span> doesn\&#x27;t exist.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> check_author <span class="keyword">and</span> post[<span class="string">&#x27;author_id&#x27;</span>] != g.user[<span class="string">&#x27;id&#x27;</span>]:</span><br><span class="line">abort(<span class="number">403</span>)</span><br><span class="line"><span class="keyword">return</span> post</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/&lt;int:id&gt;/update&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">post = get_post(<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">title = request.form[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">body = request.form[<span class="string">&#x27;body&#x27;</span>]</span><br><span class="line">error = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> title:</span><br><span class="line">error = <span class="string">&#x27;Title is required.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> error <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">flash(error)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">db = get_db()</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;update post set title = ?, body = ? where id = ?&#x27;</span>,</span><br><span class="line">(title, body, <span class="built_in">id</span>)</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;blog.index&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;blog/update.html&#x27;</span>, post = post)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&#x27;/&lt;int:id&gt;/delete&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">get_post(<span class="built_in">id</span>)</span><br><span class="line">db = get_db()</span><br><span class="line">db.execute(</span><br><span class="line"><span class="string">&#x27;delete from post where id = ?&#x27;</span>, (<span class="built_in">id</span>,)</span><br><span class="line">)</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;blog.index&#x27;</span>))</span><br></pre></td></tr></table></figure><p>最后的blog.py并没有什么要讲的。就是简单的crud。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起因&quot;&gt;#&lt;/a&gt;起因&lt;/h1&gt;
&lt;p&gt;最近简单看了flask的文档。&lt;br&gt;
然后把里面&lt;a href=&quot;https://dormousehole.readthedocs.io/en/lat</summary>
      
    
    
    
    <category term="后端" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/categories/%E5%90%8E%E7%AB%AF/flask/"/>
    
    
    <category term="后端" scheme="http://localhost:5000/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="flask" scheme="http://localhost:5000/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>Pattern: Backends For Frontends 翻译尝试</title>
    <link href="http://localhost:5000/2022/11/24/frontend-bff-1/"/>
    <id>http://localhost:5000/2022/11/24/frontend-bff-1/</id>
    <published>2022-11-23T15:44:28.000Z</published>
    <updated>2022-11-25T09:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pattern: Backends For Frontends</p><h1 id="模式：backends-for-frontends"><a class="header-anchor" href="#模式：backends-for-frontends">#</a>模式：Backends For Frontends</h1><p>Written on Nov 18 2015<br>写于 2015.11.18<br>Single-purpose Edge Services for UIs and external parties<br>针对UI和外部的单一目标的边缘服务</p><p>Introduction</p><h1 id="介绍"><a class="header-anchor" href="#介绍">#</a>介绍</h1><p>With the advent and success of the web, the de facto way of delivering user interfaces has shifted from thick-client applications to interfaces delivered via the web, a trend that has also enabled the growth of SAAS-based solutions in general. The benefits of delivering a user interface over the web were huge - primarily as the cost of releasing new functionality was significantly reduced as the cost of client-side installs was (in most cases) eliminated altogether.<br>随着web技术出现并取得成功，与用户的交互已经从厚重的客户端转向通过web界面，这一趋势也推动了基于SAAS的方案的增长。使用web界面与用户交互的好处是巨大的————主要是由于发布新功能的成本显著降低，大多数情况下客户端安装的成本被完全消除。</p><p>This simpler world didn’t last long though, as the age of the mobile followed shortly afterwards. Now we had a problem. We had server-side functionality which we wanted to expose both via our desktop web UI, and via one or more mobile UIs. With a system that had initially been developed with a desktop-web UI in mind, we often faced a problem in accommodating these new types of user interface, often as we already had a tight coupling between the desktop web UI and our backed services.<br>然而随着移动时代的到来，这个简单的世界并没有持续多久。现在我们遇到了一个问题：我们希望通过web端的UI和移动端的UI调用服务端的功能，但是在最初考虑到桌面端UI的系统的时候，我们发现桌面端UI与服务端的接口之间已经紧密耦合。</p><p>The General-Purpose API Backend</p><h1 id="通用api后端"><a class="header-anchor" href="#通用api后端">#</a>通用API后端</h1><p>A first step in accommodating more than one type of UI is normally to provide a single, server-side API, and add more functionality as required over time to support new types of mobile interaction:<br>适应多种UI的第一步通常是提供单一的服务端API，并根据需求添加更多功能，以支持新类型的移动交互<br><img src="./single-api.jpg" alt="" title="通用API后端"></p><figcaption>通用API后端</figcaption><p>If these different UIs want to make the same or very similar sorts of calls, then it can be easy for this sort of general-purpose API to be successful. However the nature of a mobile experience often differs drastically from a desktop web experience. Firstly, the affordances of a mobile device are very different. We have less screen real estate, which means we can display less data. Opening lots of connections to server-side resources can drain battery life and limited data plans. And secondly, the nature of the interactions we want to provide on a mobile device can differ drastically. Think of a typical bricks-and-mortar retailer. On a desktop app I might allow you to look at the items for sale, order online or reserve in store. On the mobile device though I might want to allow you scan bar codes to do price comparisons or give you context-based offers while in store. As we’ve built more and more mobile applications we’ve come to realise that people use them very differently and therefore the functionality we need to expose will differ too.<br>如果这些不同的UI想要有相同的或相似的调用，那么这种通用API很容易成功。然而，移动端和桌面端的体验本质上截然不同。首先，移动端UI的可利用资源与桌面端截然不同。我们有更少的屏幕空间，这意味着我们只能显示更少的数据；向服务器发送大量请求可能会消耗电池寿命和电池电量。其次，我们希望在移动端提供的用户交互会有很大不同。比如典型的实体零售商。在桌面端，我们可能会允许用户查看待售商品、在线订购和在商店预定。但在移动端，我可能会让用户扫描条形码进行价格比较，或者在商店里基于用户历史习惯提供内容。随着我们构建了越来越多的移动应用程序，我们开始意识到用户使用它们的方式非常不同，因此我们需要提供的功能（提供的接口？）也会有所不同。</p><p>So in practice, our mobile devices will want to make different calls, fewer calls, and will want to display different (and probably less) data than their desktop counterparts. This means that we need to add additional functionality to our API backend to support our mobile interfaces.<br>因此，在实践中，我们的移动端希望有不同的请求，更少的请求，与桌面端相比展示不同（一般情况下是更少）的数据。这意味着我们需要在后端API添加额外的功能，支持我们的移动端。</p><p>Another problem with the general-purpose API backend is that they are by definition providing functionality to multiple, user-facing applications. This means that the single API backend can become a bottleneck when rolling out new delivery, as so many changes are trying to be made to the same deployable artifact.<br>通用API后端的另一个问题是，它为不同用户界面提供功能。这意味着，单一的后端API成为了瓶颈，当提供新的功能交付时，对一个可部署工件会做许多更改。</p><p>The tendency for the general-purpose API backend to take on multiple responsibilities, and therefore require lots of work, often results in a team being created specifically to handle this code base. This can make the problem much worse, as now front-end teams have to interface with a separate team to get changes made - a team which will have to balance both the priorities of the different client teams, and also work with multiple downstream teams to consume new APIs as they become available. It could be argued that at this point we have just created a smart-piece of middleware in our architecture, something which is not focused on any particular business domain - something which goes against many people’s views of what sensible Service Oriented Architecture should look like.<br>随着通用后端API承担越来越多的功能，会产生大量工作需求，结果就是需要专门创建一个团队来管理后端代码。这可能会导致问题变得更糟：现在前端团队会为了需求更改与另一个团队（后端）来进行沟通————而后端团队也必须平衡多种不同客户端之间的需求，并且与多个下游团队合作，创建新的可用API。就这样我们创建了一个智能的中间件，但是它没有专注于任何特定的业务领域，与人们对于面向服务的智能体系架构的想法相违背。</p><p><img src="general-purpose-api-teams.jpg" alt="" title="使用通用支持API时的通用团队结构"></p><figcaption>使用通用支持API时的通用团队结构</figcaption><p>Introducing The Backend For Frontend<br>Backend For Frontend介绍</p><p>One solution to this problem that I have seen in use at both REA and SoundCloud is that rather than have a general-purpose API backend, instead you have one backend per user experience - or as (ex-SoundClouder) Phil Calçado called it a Backend For Frontend (BFF). Conceptually, you should think of the user-facing application as being two components - a client-side application living outside your perimeter, and a server-side component (the BFF) inside your perimeter.<br>我在REA和SoundCloud看到的这个问题的一个解决方案就是，为每一个用户UI创建一个后端，取消原来的通用后端API————这被一位前SoundClouder Phil Calçado成为Backend For Frontend (BFF)。从概念上讲，应当将面向用户的应用程序分为两个组件————一个是在外的客户端应用程序，一个是在内的服务端组件（BFF）。</p><p>The BFF is tightly coupled to a specific user experience, and will typically be maintained by the same team as the user interface, thereby making it easier to define and adapt the API as the UI requires, while also simplifying process of lining up release of both the client and server components.<br>BFF与特定的用户UI紧密耦合，通常由构建用户界面的团队进行维护，从而使得根据UI的需求定制调整API变得更加容易，同时也简化了客户端和服务器组件的发布流程。<br><img src="bff-overview.jpg" alt="" title="每一个用户界面使用一个服务端的BFF"></p><figcaption>每一个用户界面使用一个服务端的BFF</figcaption><p>BFF专注于一个单独的UI，这使得它能够被定制化，从而变得更小型化。</p><p>How Many BFFs?<br>我们需要多少个BFF？</p><p>当谈到为不同平台提供相同（或相似）的用户体验时，我看到了两种不同的方案。我更喜欢的模型是阉割为每种不同的客户端提供一个BFF————这是我在REA看到的一个模型：<br><img src="one-bff-per-mobile.jpg" alt="" title="不同的移动平台，不同的BFF，在REA中"></p><figcaption>不同的移动平台，不同的BFF，在REA中</figcaption><p>The other model, which I have seen in use at SoundCloud, uses one BFF per type of user interface. So both the Android and iOS versions of the listener native application use the same BFF:<br>另一种模型，就像我在SoundCloud看到的，为每种类型的用户界面创建一个BFF。所以Android和iOS使用了同一个移动端的BFF：<br><img src="generic-mobile-bff.jpg" alt="" title="为不同的移动端创建一个BFF，在SoundCloud中"></p><figcaption>为不同的移动端创建一个BFF，在SoundCloud中</figcaption><p>My main concern with the second model is just that the more types of clients you have using a single BFF, the more temptation there may be for it to become bloated by handling multiple concerns. The key thing to understand here though is that even when sharing a BFF, it is for the same class of user interface - so while SoundCloud’s listener Native applications for both iOS and Android use the same BFF, other native applications would use different BFFs (for example the new Creator application Pulse uses a different BFF). I’m also more relaxed about using this model if the same team owns both the Android and iOS applications and own the BFF too - if these applications are maintained by different teams, I’m more inclined to recommend the more strict model. So you can see your organisation structure as being one of the main drivers to which model makes the most sense (Conway’s Law wins again). It’s worth noting that the SoundCloud engineers I spoke to suggested that having one BFF for both Android and iOS listener applications was something they might reconsider if making the decision again today.<br>我对于第二个模型的主要担忧是，随着使用单一BFF的客户端类型越多，处理多种请求可能会导致体积臃肿。这里需要理解的关键是，即使共享同一个BFF，它也适用于同一类用户界面————因此当SoundCloud的侦听器侦听到Android和iOS的客户端时，会调用移动端的BFF；侦听到其他类型的客户端时，会调用其他的BFF（例如新出的应用Pulse使用了不同的BFF）。如果是由同一个团队负责Android和iOS的客户端以及对应的BFF时，我也更乐于使用第二种模式————反之，如果是由不同的团队分别负责，我更倾向于更严格的第一种模式。因此，你可以将你的组织架构思维模型选择的主要驱动因素之一（康威定律再次获胜）。值得一提的是，当年我口中说的为Android和iOS的客户端提供一个BFF的SoundCloud工程师说，如果是今日再选择BFF可能会重新考虑方案（或许是与往日不同的组织架构？）。</p><p>One guideline that I really like from Stewart Gleadow (who in turn credited Phil Calçado and Mustafa Sezgin) was ‘one experience, one BFF’. So if the iOS and Android experiences are very similar, then it is easier to justify having a single BFF. If however they diverge greatly, then having separate BFFs makes more sense.<br>我非常喜欢Stewart Gleadow（他反过来称赞Phil Calçado和Mustafa Sezgin）的一条指导原则，“一种体验，一个BFF”。因此，如果iOS和Android的用户体验非常相似，那么更容易证明拥有一个BFF是合理的。反之，如果两者的用户体验分歧巨大，那么拥有单独的BFF更合理。</p><p>Pete Hodgson made the observation that BFFs work best when aligned around team boundaries, so team structure should drive how many BFFs you have. So that if you have a single mobile team, you should have one BFF, but if you had separate iOS and Android teams, you’d have separate BFFs. My concern is that team structures tend to be more fluid than our system design. So if you have a single BFF for mobile, then split the team into iOS and Android specialisations, do you then have to split the BFF too? If the BFFs were already separate, then splitting the team would be easier as you can reassign ownership of the already independent asset. The interplay of BFF and team structure is important though, something we’ll explore more shortly.<br>Pete Hodgson观察到，围绕团队架构来构建BFF时BFF的工作情况最佳，因此团队结构决定你应构建多少BFF。因此，如果你有一个单一的移动端团队，应该为此构建一个BFF；如果有分开的Android和iOS团队，应该为之分别构建BFF。我担心的是，团队结构往往比我们的系统架构设计更具流动性。所以，当你的单独的移动端团队被分割成Android和iOS两个团队时，是否也必须拆分BFF？如果BFF已经拆分，那么拆分软对将更容易，因为你可以重新分配独立资产的所有权。BFF和团队结构之间的相互作用很重要，我们稍后会对此进行深入探讨。</p><p>Often the driver towards having a smaller number of BFFs is around reusing server-side functionality to avoid too much duplication, but there are other ways to handle this which we’ll cover shortly.<br>通常，占驱动因素较小比重的是重用服务端功能，避免过多的冗余。但这里还有其他方案解决这一问题，我们将很快介绍。</p><p>And Multiple Downstream Services (Microservices!)</p><h1 id="以及多个下游服务-微服务"><a class="header-anchor" href="#以及多个下游服务-微服务">#</a>以及多个下游服务（微服务！）</h1><p>BFFs can be a useful pattern for architectures where there are a small number of backend services. For organisations using a large number of services however they can be essential, as the need to aggregate multiple downstream calls to deliver user functionality increases drastically. In such situations it will be common for a single call in to a BFF to result in multiple downstream calls to microservices. For example, imagine an application for an e-commerce company. We want to pull back a list of items in a user’s wish list, displaying stock levels, and price:<br>BFF对于后端服务较少的架构来说是一种可选的模式。但是对于提供大量服务的组织来说，由于聚合多个下游调用以提供用户功能的需求急剧增加，BFF是必不可少的。在这种情况下，对BFF的单个调用，会导致对微服务的多个下游调用。例如，想象一个电子商务公司的应用程序。我们希望返回一个用户的愿望清单，显示库存水平和价格：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>The Brakes - Give Blood</td><td>In Stock! (14 items remaining)</td><td>$5.99</td><td>order now</td></tr><tr><td>Blue Juice - Retrospectable</td><td>Out Of Stock</td><td>$17.50</td><td>pre order</td></tr><tr><td>Hot Chip - Why Make Sense?</td><td>Going fast (2 items left)</td><td>$9.99</td><td>order now</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Brakes - Give Blood</td><td>现货! (14件剩余)</td><td>$5.99</td><td>下单</td></tr><tr><td>蓝汁 - Retrospectable</td><td>售空</td><td>$17.50</td><td>预定</td></tr><tr><td>Hot Chip - Why Make Sense?</td><td>库存量少 (2件剩余)</td><td>$9.99</td><td>下单</td></tr></tbody></table><p>其实三项都是音乐专辑。。</p><p>Multiple services hold the pieces of information we want. The Wishlist service stores information about the list, and IDs of each item. The Catalog service stores the name and price of each item, and the Stock levels are stored in our inventory service. So in our BFF we’d expose a method for retrieving the full playlist, which would consist of at least 3 calls:<br>一个服务只包含我们需要的部分信息。其中，Wishlist服务存储清单的信息以及每件商品的ID，Catalog服务存储每件商品的名称和价格，Stock服务存储了库存数量信息。所以，在我们的BFF中，将创建一个检索完整播放列表的方法，该方法至少包含三个调用：</p><p><img src="sequence.jpg" alt="" title="构建愿望清单，需要调用多个下游服务"></p><figcaption>构建愿望清单，需要调用多个下游服务</figcaption><p>From an efficiency point of view, it would be much smarter to run as many calls in parallel as possible. Once the initial call to the Wishlist service completes, ideally we’d like to then run the calls to the other services at the same time to reduce the overall call time. This need to mix calls that we want to run in parallel vs those that run in sequence can quickly become painful to manage, especially for more complex scenarios. This is one area where a reactive style of programming can help (such as that provided by RxJava or Finagle’s futures system) as the composition of multiple calls becomes easier to manage.<br>从效率的角度来看，尽可能多地并行调用会更好。所以，一旦Wishlist服务调用完成，我们应立即调用剩余所有的服务。这种需要并行调用和顺序调用的方式混合，可能会使得代码变得难以管理，尤其是对于更复杂的场景。这就是一个反应式编程风格可以解决的领域（例如RxJava或Finagle的期货系统提供的编程风格），这种方式可以使多个调用的组合变得容易管理。</p><p>Failure modes though become important to understand. In our example above, we could insist that all downstream calls have to return in order for us to return a payload to our client. However is this sensible? Obviously we can’t do anything if the Wishlist service is down, but if only the Inventory service was down, wouldn’t it be better to just degrade the functionality we pass back to the client, perhaps just by removing the stock level indicator? These concerns have to be managed by the BFF itself in the first instance, but we also need to make sure that the client making the call to the BFF can interpret a partial response and render it correctly.<br>了解故障处理也很重要。在上面的示例中，我们可以假设所有下游调用都必然有返回，以便我们想客户端返回有效内容。然而，这是现实的吗？显然，如果Wishlist服务宕机，我们无计可施，但如果仅有Inventory服务宕机了呢？我们减少返回给客户端的数据不就可以了吗？也许只是删掉库存水平显示功能？这些问题必须由BFF自己管理，但我们还需要确保调用BFF的客户端能够解析返回的不全信息并能够正确显示。</p><p>Reuse and BFFs</p><h1 id="重用和bff"><a class="header-anchor" href="#重用和bff">#</a>重用和BFF</h1><p>One of the concerns of having a single BFF per user interface is that you can end up with lots of duplication between the BFFs themselves. For example they may end up performing the same types of aggregation, have the same or similar code for interfacing with downstream services etc. Some people react to this by wanting to merge these back together, and so have a general-purpose aggregating Edge API service. This model has proven time and again to lead to highly bloated code with multiple concerns squashed together.<br>每个用户界面配一个BFF的问题之一是，BFF之间可能会出现大量冗余。例如，他们最终可能会有相同类型的功能，与下游服务会有相同或类似的代码调用。一些人想要将这些冗余整合，于是诞生了通用目的的边缘API聚合服务模型。这个模型一次又一次证明会导致代码高度臃肿，多个关注点挤在一起。</p><p>As I have said many times before, I am fairly relaxed about duplicated code across services. Which is to say that while in a single process boundary I will typically do whatever I can to refactor out duplication into suitable abstractions, I don’t have the same reaction when confronted by duplication across services. This is mostly as I am often more worried about the potential for extracting shared code to lead to tight coupling between services - something I am more worried about than duplication in general. That said, there are certainly cases where this is warranted.<br>正如之前提及，我对于跨服务之间的代码冗余相当宽松。也就是说，在同一个流程中，我会尽可能将代码冗余抽象重构；但当遇到跨服务之间的冗余时，我就不会这样做。这主要是因为我更担心抽象重构会导致服务之间的紧密耦合，而这令我更加担心。也就是说，在某些情况下，代码冗余是有必要的。</p><p>My colleague Pete Hodgson has pointed out that when you don’t have BFFs, then often the ‘common’ logic ends up being baked into the different clients themselves. Due to the fact that these clients use very different technology stacks, identifying the fact that this duplication is occurring can be difficult. With organisations tending to have a common technology stack for server-side components, having multiple BFFs with duplication may be easier to spot and factor out.<br>我的同事Pete Hodgson指出，当你没有BFF时，经常会为不同的客户端提供一些共同的功能。由于这些客户端使用了非常不同的技术堆栈，因此很难确定这种“共同”存在的事实。随着为服务端提供共同的技术堆栈，拥有多个重复的BFF可能更容易发现排除问题所在。</p><p>When the time does arise to extract shared code, there are two obvious options. The first, which is often cheapest but more fraught, is to extract a shared library of some sort. The reason this can be problematic is that shared libraries are a prime source of coupling, especially when used to generate client-libraries for calling downstream services. Nonetheless there are situations where this feels right - especially when the code being abstracted is purely a concern inside the service.<br>当需要提取共享代码时，有两个明显的选择：一是提取出某种类型的共享库，这通常是成本最低且更令人担忧的。这是因为，这些共享库往往就是耦合的主要来源，尤其是生成用于调用下游服务的客户端库时。尽管如此，在某些情况下是正确的选择，特别当抽取共享代码时一个服务的内部的问题时。</p><p>The other option is to extract out the shared functionality in a new service, which can work well if you can conceptualise the new service has something modeled around the domain in question.<br>另一种选择是提取出一个新服务的共享功能。如果你能够将新服务概念化，那么它可以很好地工作。</p><p>A variation of this approach might be to push aggregation responsibilities to services further downstream. Take the example above where we discussed rendering of a wish list. Let’s imagine we are rendering a wishlist in two places - on Android, iOS Web. Each of our BFFs are making the same three calls:<br>这种选择的一种变体，或许是将公共功能提取出来作为一种下游服务。以上面的例子举例，我们探讨了愿望清单的实现。让我们想象一下，我们需要在Android和iOS两个地方提高愿望清单。我们的每个BFF都进行相同的三个调用：<br><img src="bff-duplication.jpg" alt="" title="多个BFF实现相同的功能"></p><figcaption>多个BFF实现相同的功能</figcaption><p>Instead, we could change the Wishlist service to make the downstream calls for us, thereby simplifying the job for the callers:<br>相反，我们可以更改Wishlist服务，将其作为一种下游服务，从而简化调用：<br><img src="removing-duplication.jpg" alt="" title="将公共功能作为下游服务，消除BFF中的代码冗余"></p><figcaption>将公共功能作为下游服务，消除BFF中的代码冗余</figcaption><p>I have to say that the same code being used in two places wouldn’t necessarily cause me to want to extract out a service in this way, but I’d be certainly considering it if the transaction cost of creating a new service was low enough, or I was using it in more than a couple of places (for example maybe on the desktop web). I think the old adage of creating an abstraction when you’re about to implement something for the 3rd time still feels like a good rule of thumb, even at the service level.<br>我不得不说，仅在两个地方使用冗余代码不一定让我想到以这种方式处理，但如果创建一个新的下游服务的成本足够低，或者我将在多个地方使用它（例如，可能在桌面web上），我肯定会考虑这样做。我认为，即使在你需要第三次实现某个东西时，进行抽象重构仍然是一个很好的经验法则。</p><p>BFFs for Desktop Web and Beyond</p><h1 id="桌面端的bff以及延伸"><a class="header-anchor" href="#桌面端的bff以及延伸">#</a>桌面端的BFF以及延伸</h1><p>You can think of BFFs as just having a use in solving the constraints of mobile devices. The desktop web experience is typically delivered on more powerful devices with better connectivity, where the cost of making multiple downstream calls is manageable. This can allow your web application to make multiple calls directly to downstream services without the need for a BFF.<br>你可以将BFF视为解决移动端的限制条件的良药。桌面web通常功能更加强大，会运行在性能更强的设备商，在这些设备上调用多个下游服务的成本是可控的。这可以允许你的web应用程序直接调用多个下游服务，而无需BFF。</p><p>I have seen situations though where the use of a BFF for the web too can be useful. When you are generating a larger portion of the web UI on the server-side (e.g using server-side templating), a BFF is the obvious place where this can be done. It can also simplify caching somewhat as you can place a reverse proxy in front of the BFF, allowing you to cache the results of aggregated calls (although you have to make sure you set your cache controls accordingly to ensure that the aggregated content’s expiry is as short as the freshest piece of content in the aggregation needs it to be). I’ve seen it used multiple times in fact without calling it a BFF - in fact the general-purpose API backend often grows from such a beast.<br>不过，我也见过在web端使用BFF的情况。当你在服务器端生成大部分web UI的时候（例如使用服务端模板），BFF很明显可以做到这一点。你也可以在BFF前放置一个反向代理，允许你缓存调用的结果（虽然你必须相应地设置缓存空间，确保聚合内容的到期时间和聚合中最新内容所需时间一样短）。实际上，我见过它多次被使用，但没有将其成为BFF–事实上，通用API后端通常是从这样一个庞然大物成长起来的。</p><p>I’ve seen at least one organisation use BFFs for other external parties that need to make calls. Coming back to my perennial example of a music shop, I might expose a BFF to allow 3rd parties to extract royalty payment information, provide Facebook integration or allow streaming to a range of set-top box devices:<br>我至少见过一个组织为第三方的接口调用提供一个BFF。回到我之前提到的音乐商店的例子，我可能hi暴露一个BFF，允许第三方提取版税支付信息，提供Facebook集成，或允许为一系列机顶盒设备提供流服务。<br><img src="3rd-parties.jpg" alt="" title="使用BFF为第三方提供API"></p><figcaption>使用BFF为第三方提供API</figcaption><p>This approach can be especially effective as third-parties often have limited to no ability (or desire) to use or change the API calls they make. With a general-purpose API backend, you may have to keep old versions of the API around just to satisfy a small subset of your outside parties unable to make a change - with BFF this problem is substantially reduced.<br>这种方法相当有效，因为第三方通常无法（或者不希望）使用或修改他们所做的API调用。如果使用通用API后端，您可能不得不保留旧版本的API，以满足一小部分服务于第三方的需要————使用BFF将大大减少这一问题。</p><p>And Autonomy</p><h1 id="分散定律"><a class="header-anchor" href="#分散定律">#</a>分散定律</h1><p>Quite often we see situation where one team is working on a frontend, and a different team is creating the backend services. In general, we’re trying to avoid this by moving to microservices which are aligned around business verticals, but even then there are situations where this is hard to avoid. Firstly, at a certain level of scale or complexity, multiple teams need to get involved. Secondly, the depth of technical skills required to execute a good Android or iOS experience often need specialised teams.<br>我们通常看到这样的情况：一个团队负责前端，另一个团队扶着创建后端服务。一般来说，我们通过构建围绕业务纵向的微服务来试图避免这种情况。但即使如此，也存在难以避免的情况。首先，如果项目达到一定规模和复杂程度，就需要多个团队参与。其次，实现Android或iOS交互体验需要的专业技能需要一支专业的团队。</p><p>So teams building user interfaces are confronted with the situation that they are calling an API which another team is driving, and often than API is evolving while the user interface is being developed. The BFF can help here, especially if it is owned by the team creating the user interface. They evolve the API of the BFF at the same time as creating the front end. They can iterate both quickly. The BFF itself still needs to call the other downstream services, but this can be done without having to interrupt development of the user interface.<br>因此，构建用户界面的团队面临的情况是，他们正在调用另一个团队驱动开发的API，而在开发用户界面的过程中，API往往不断演变。BFF可以在这里提供帮助，特别是如果它是由创建用户界面的团队负责。他们在构建前端的同时，也完善了BFF的API。他们可以快速迭代。BFF本身仍然需要调用其他下游服务，但这可以在不中断用户界面开发的情况下完成。<br><img src="team-ownership.jpg" alt="" title="使用BFF的团队的所有权界限"></p><figcaption>使用BFF的团队的所有权界限</figcaption><p>The other benefit of using a BFF aligned along team boundaries like this is that the team creating the interface can be much more fluid in thinking about where functionality lives. For example they could decide to push functionality on to the server-side to promote reuse in the future and simplify a native mobile application, or to allow for the faster release of new functionality (as you can bypass the app store review processes). This decision is one that can be made by the team in isolation if they own both the mobile application and the BFF - it doesn’t require any cross-team coordination.<br>使用这样的与团队架构一致的BFF的好处是，创建界面的团队在思考功能时会更加灵活。例如，他们可以决定将功能推到服务端，以促进未来的重用并简化本地移动端程序，或者允许更快地发布新功能（因为你可以绕过应用商店审查流程）。如果团队同时拥有移动端和BFF，则可以单独做出这一决定————这不需要任何团队协调。</p><p>General Perimeter Concerns</p><h1 id="一般周边问题"><a class="header-anchor" href="#一般周边问题">#</a>一般周边问题</h1><p>Some people use BFFs to implement generic perimeter concerns, such as authentication/authorisation or request logging. I’m torn about this. On the one hand, much of this functionality is so generic that I’d be inclined to implement it using another layer sitting further upstream, perhaps using something like a tier of Nginx or Apache servers. On the other hand, such an additional layer can’t help but add latency. BFFs are often used in microservice environment where we are already very sensitive about latency due to the high number of network calls being made. Also, the more layers you have to deploy to make a production-like stack can make development and test more complex - having all of these concerns inside the BFF as a more self-contained solution can be attractive as a result:<br>一些人使用BFF来解决一般的外围问题，例如身份验证/授权或请求日志记录。我为此感到难过。一方面，这种功能的大部分是通用的，所以我倾向于使用更上游的一层来实现它，可能使用Nginx或者Apache之类的东西。另一方面，这样的附加层会增加延迟。BFF通常用于微服务环境，在微服务环境中，由于进行了大量的网络调用，我们对延迟非常敏感。此外，为了制作类似生产的堆栈，你必须部署的层越多，开发和测试就越复杂。因此，将所有这些问题作为一个更独立的解决方案放在BFF中可能会更有吸引力：<br><img src="perimeter-layer.jpg" alt="" title="使用网络应用实现一般的外围问题"></p><figcaption>使用网络应用实现一般的外围问题</figcaption><p>As we discussed earlier, another way to factor out this duplication could be to use a shared library. Assuming your BFFs are using the same technology, this shouldn’t be too difficult, although the usual caveats about shared libraries in a microservice architecture apply.<br>正如我们之前讨论的，消除这种冗余的另一种方案就是使用共享库。假设你的BFF使用相同的技术，这应该不会太困哪，尽管微服务架构中共享库的常见警告仍然适用。</p><p>When To Use</p><h1 id="何时应用"><a class="header-anchor" href="#何时应用">#</a>何时应用</h1><p>For an application which is only providing a web UI, I suspect a BFF will only make sense if and when you have a significant amount of aggregation required on the server-side. Otherwise, I think other UI composition techniques can work just as well without requiring an additional server-side component (I’ll hopefully talk about those soon).<br>对于只提供web UI的应用程序，我怀疑只有在服务端需要大量聚合时，BFF才有意义。否则，我认为其他UI组合技术也可以正常工作，而不需要额外的服务端组件（我希望很快就会讨论这些）。</p><p>The moment that you need to provide specific functionality for a mobile UI or third party though, I would strongly consider using a BFFs for each party from the outset. I might reconsider if the cost of deploying additional services is high, but the separation of concerns that a BFF can bring make it a fairly compelling proposition in most cases. I’d be even more inclined to use a BFF if there is a significant separation between the people building the UI and downstream services, for reasons outlined above.<br>当你需要为移动端或第三方提供特定功能时，我会强烈考虑从一开始就为每一方构建一个BFF。如果部署额外服务的成本很高，我可能会重新考虑，但BFF可能带来的消解耦合使它在大多数情况下是一个相当有说服力的建议。如果构建UI的人员和下游服务之间存在明显的分离，处于上述原因，我更倾向于使用BFF。</p><p>Further Reading (And Viewing)</p><h1 id="延伸阅读-或访谈"><a class="header-anchor" href="#延伸阅读-或访谈">#</a>延伸阅读（或访谈）</h1><ul><li><p>Since I wrote this piece, Lukasz Plotnicki from ThoughtWorks has published a great article on SoundCloud’s use of the BFF pattern</p></li><li><p>Lukasz being interviewed about the pattern (and other things) on a recent episode of the Software Engineering Podcast.</p></li><li><p>Bora Tunca from SoundCloud also goes into more detail during a talk at microxchg 2016.</p></li><li><p>在我写了这篇文章之后，Lukasz Plotnicki在ThoughtWorks发了<a href="https://www.thoughtworks.com/insights/blog/bff-soundcloud">一篇文章</a>，讲述了在SoundCloud如何使用BFF模式</p></li><li><p>Lukasz在最近一集的Software Engineering Podcast中接受了关于模式（和其他事情）的<a href="http://softwareengineeringdaily.com/2016/02/04/moving-to-microservices-at-soundcloud-with-lukasz-plotnicki/">采访</a>。</p></li><li><p>SoundCloud的Bora Tunca也在<a href="https://www.youtube.com/watch?v=jfN6HOgURXM">一次访谈</a>中讲述了一些细节</p></li></ul><p>Conclusion</p><h1 id="结论"><a class="header-anchor" href="#结论">#</a>结论</h1><p>Backends For Frontends solve a pressing concern for mobile development when using microservices. In addition they provide a compelling alternative to the general-purpose API backend, and many teams make use of them for purposes other than just mobile development. The simple act of limiting the number of consumers they support makes them much easier to work with and change, and helps teams developing customer-facing applications retain more autonomy.<br>Backends For Frontends解决了使用微服务时移动端开发的一个紧迫问题。此外，它们为通用API后端提供了一个引人注目的替代方案，许多团队将其用于移动端开发之外的其他目的。简单地限制客户端支持的用户数量使他们更容易处理和更改，并帮助开发面向客户的应用程序的团队在开发面向客户的应用程序时保留更多的自主权。</p><p>Thanks go to Matthias Käppler, Michael England, Phil Calçado, Lukasz Plotnicki, Jon Eaves, Stewart Gleadow and Kristof Adriaenssens for their help in researching this article, and Giles Alexander, Ken McCormack, Sriram Viswanathan, Kornelis Sietsma, Hany Elemary, Martin Fowler, Vladimir Sneblic, and Pete Hodgson for general feedback. I’d really appreciate any further feedback too, so feel free to leave a comment below!<br>感谢Matthias Käppler、Michael England、Phil Calçado、Lukasz Plotnicki、Jon Eaves、Stewart Gleadow和Kristof Adriaenssens在研究本文时提供的帮助，感谢Giles Alexander、Ken McCormack、Sriram Viswanathan、Kornelis Sietsma、Hany Elemary、Martin Fowler、Vladimir Sneblic和Pete Hodgson提供的一般反馈。我也非常感谢任何进一步的反馈，所以欢迎在下面留言！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Pattern: Backends For Frontends&lt;/p&gt;
&lt;h1 id=&quot;模式：backends-for-frontends&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#模式：backends-for-frontends&quot;&gt;#&lt;/a&gt;模式</summary>
      
    
    
    
    <category term="前端" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="BFF" scheme="http://localhost:5000/categories/%E5%89%8D%E7%AB%AF/BFF/"/>
    
    
    <category term="前端" scheme="http://localhost:5000/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="BFF" scheme="http://localhost:5000/tags/BFF/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题修改1</title>
    <link href="http://localhost:5000/2022/11/23/hexo_theme_1/"/>
    <id>http://localhost:5000/2022/11/23/hexo_theme_1/</id>
    <published>2022-11-23T05:29:45.000Z</published>
    <updated>2022-11-23T13:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo基本简介"><a class="header-anchor" href="#hexo基本简介">#</a>hexo基本简介</h1><p>至于hexo的到处都是的东西我就不说了。<br>首先有render，hexo可以换render的。上网一搜就能找到，基本是<code>hexo-render</code>开头的npm包。<br>然后也有一个渲染的钩子函数之类的东西，我也不是很清楚。<br>最后也有插件。在hexo的包里就能找到<code>plugin</code>文件夹。里面就是通过插件的方式加入的hexo基础功能，比如文档里介绍的变量和函数。</p><p>渲染模板有很多，比如ejs。可以去ejs的文档里找。。</p><h1 id="修改indigo"><a class="header-anchor" href="#修改indigo">#</a>修改indigo</h1><p>indigo是hexo官网里就能找到的主题。不过直接<code>git clone</code>是使用不了的。<br>总之各种问题。</p><p>首先是lodash的问题。旧版hexo会携带lodash包，并且在变量里用<code>_</code>引入。在新版hexo中，需要用插件的方式将其引入，使得indigo可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;template_locals&#x27;</span>, <span class="function"><span class="params">locals</span> =&gt;</span> &#123;</span><br><span class="line">locals.<span class="property">_</span> = lodash;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后的日期问题。hexo文档里虽说是用<code>moment</code>来格式化时间，实际上是<code>moment-timezone</code>。</p><p>在插件文件中加入，实现月份的中文化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">moment.<span class="title function_">updateLocale</span>(<span class="string">&#x27;zh-cn&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">months</span>: [</span><br><span class="line">      <span class="string">&#x27;一月&#x27;</span>, <span class="string">&#x27;二月&#x27;</span>, <span class="string">&#x27;三月&#x27;</span>, <span class="string">&#x27;四月&#x27;</span>, <span class="string">&#x27;五月&#x27;</span>, <span class="string">&#x27;六月&#x27;</span>, <span class="string">&#x27;七月&#x27;</span>, <span class="string">&#x27;八月&#x27;</span>, <span class="string">&#x27;九月&#x27;</span>, <span class="string">&#x27;十月&#x27;</span>, <span class="string">&#x27;十一月&#x27;</span>, <span class="string">&#x27;十二月&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">moment.<span class="title function_">locale</span>()</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">helper</span>.<span class="title function_">register</span>(<span class="string">&#x27;data_format&#x27;</span>, <span class="function">(<span class="params">date, format</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">moment</span>(date).<span class="title function_">format</span>(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="本人的其他修改"><a class="header-anchor" href="#本人的其他修改">#</a>本人的其他修改</h1><p>细节就不多说了。<br>比如简单的格式修改。<br>还有滚动文章页面时，原代码里劫持了事件，我给注释了。<br>就是这篇文章。。页内锚点链接需要<code>encodeURI</code>转换。</p><p>重点是<code>tag</code>和<code>category</code>。初用者一定不清楚两者之间区别。<br>实际上，<code>tag</code>译为标签，一篇文章里的标签之间是平级关系；<code>category</code>却不是。<br>可以在hexo中的<code>plugin</code>文件夹里寻找到<code>list_categories</code>函数的实现。顺便在插件文件中复制一份，并且打印一下<code>category</code>就会发现，它是有<code>parent</code>这种东西的。<br>所以我就将其作为目录一样的存在，并在插件中实现了一下，在<code>/categories</code>路径下渲染了一下。</p><h1 id="最后"><a class="header-anchor" href="#最后">#</a>最后</h1><p>最后的结果，虽然页面和原先很像，但也经过一定的美化，并且在新版的hexo变得可用了，更符合我的心意。<br>然后我上传到github上，<a href="https://github.com/el-psy/my-hexo-theme">my-hexo-theme</a><br>自己用的时候别范那种把我的邮箱放到最终页面上的低级错误。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo基本简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#hexo基本简介&quot;&gt;#&lt;/a&gt;hexo基本简介&lt;/h1&gt;
&lt;p&gt;至于hexo的到处都是的东西我就不说了。&lt;br&gt;
首先有render，hexo可以换render的。上网一搜就能找到</summary>
      
    
    
    
    <category term="hexo" scheme="http://localhost:5000/categories/hexo/"/>
    
    <category term="主题" scheme="http://localhost:5000/categories/hexo/%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="hexo主题" scheme="http://localhost:5000/tags/hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
